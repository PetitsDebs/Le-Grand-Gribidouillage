<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <!-- Zoom natif désactivé ; pinch géré par l’app -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Le Grand Gribidouillage</title>
  <style>
    :root{
      --ui-scale: 1;
      --pal-scale: 1;
      --bar-h: 92px;
      --bar-pad: 10px;
      --gap: 8px;
      --sw: 28px;
      --cols: 14;
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-top: env(safe-area-inset-top, 0px);
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100dvh;
      min-height: 100dvh;
      height: -webkit-fill-available;
      overflow: hidden;
      background:#fff;
    }
    body { font-family: system-ui, sans-serif; margin: 16px; padding-bottom: var(--safe-bottom); }
    h1 { margin: 0; font-size: 18px; }
    .titlebar{ display:flex; align-items:center; gap:10px; margin-bottom:8px; flex-wrap: wrap; }
    .titlebar, #uiBar{ transform: scale(var(--ui-scale)); transform-origin: top left; }
    .ui { display:flex; gap:16px; align-items:center; margin-bottom:12px; flex-wrap: wrap; }
    .dim { opacity:.7 }
    #pseudoBtn{ padding: 6px 10px; border:1px solid #aaa; border-radius:8px; background:#fff; cursor:pointer; }
    #viewport{ position: fixed; left: 0; right: 0; overflow: auto; overscroll-behavior: contain; -webkit-overflow-scrolling: touch; touch-action: pan-x pan-y; background: #fff; z-index: 1; contain: size layout; }
    #space{ position: relative; }
    #sizer{ width: 1px; height: 1px; }
    #stageWrap{ position: absolute; top: 0; left: 0; display:inline-block; transform-origin: top left; transition: transform 120ms ease-out; will-change: transform; contain: layout paint; }
    #board{ image-rendering: pixelated; border:1px solid #333; touch-action: manipulation; display:block; }

    #paletteBar{
      position: fixed; left: 50%;
      transform: translateX(-50%) scale(var(--pal-scale));
      transform-origin: bottom center;
      bottom: calc(8px + var(--safe-bottom));
      max-width: min(100vw - 16px, 1100px);
      padding: var(--bar-pad);
      border:1px solid #333; border-radius:14px; background:#fff;
      box-shadow: 0 6px 18px rgba(0,0,0,.14);
      display:grid; grid-template-columns: 1fr auto auto; align-items:center; gap:10px; z-index:10;
      contain: content; will-change: contents;
    }
    #paletteGrid{ display:grid; grid-auto-flow: row dense; grid-template-columns: repeat(var(--cols), var(--sw)); grid-auto-rows: var(--sw); row-gap: var(--gap); column-gap: var(--gap); place-items:center; }
    .sw{ width:var(--sw); height:var(--sw); border:1px solid #000; border-radius:6px; cursor:pointer; }
    .activeSw{ outline:2px solid #000; outline-offset:2px; }
    .dockZoom{ display:flex; flex-direction:column; gap:6px; align-items:center; justify-content:center; }
    .dockZoom button{ width:36px; height:28px; border:1px solid #aaa; border-radius:8px; background:#fff; cursor:pointer; font-size:16px; line-height:1; }
    .sizeControls{ display:flex; gap:6px; align-items:center; justify-content:center; }
    .sizeControls button{ width:36px; height:28px; border:1px solid #aaa; border-radius:8px; background:#fff; cursor:pointer; font-size:16px; line-height:1; }
    .zoomControls{ display:flex; gap:8px; align-items:center; }
    .zoomControls button{ cursor:pointer; padding:6px 10px; border:1px solid #aaa; border-radius:8px; background:#fff; }
    .zoomControls .level{ min-width:48px; text-align:center; font-variant-numeric: tabular-nums; }
    .toggle{ display:flex; gap:6px; align-items:center; }

    #trackerTip{ position: fixed; z-index: 20; pointer-events: none; background: rgba(255,255,255,0.96); border: 1px solid rgba(0,0,0,0.25); border-radius: 8px; padding: 6px 8px; font-size: 12px; box-shadow: 0 6px 18px rgba(0,0,0,.12); transform: translate(-50%, -120%); display: none; white-space: nowrap; will-change: left, top, transform; }
    #trackerTip .xy{ font-weight: 600; margin-right: 6px; }
    #trackerTip .meta{ opacity: .8; }

    .modal[hidden]{ display:none; }
    .modal{ position: fixed; inset: 0; z-index: 30; }
    .modal-backdrop{ position: absolute; inset: 0; background: rgba(0,0,0,.35); }
    .modal-card{ position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); width: min(420px, calc(100vw - 32px)); background:#fff; border:1px solid #ccc; border-radius:12px; padding:16px; box-shadow: 0 12px 28px rgba(0,0,0,.24); }
    .modal-card h2{ margin:0 0 6px 0; font-size:18px; }
    .modal-card .hint{ margin:0 0 10px 0; opacity:.75; font-size: 12px; }
    .modal-card input{ width:100%; padding:10px; font-size:16px; border:1px solid #bbb; border-radius:8px; }
    .modal-actions{ margin-top:12px; display:flex; gap:8px; justify-content:flex-end; }
    .modal-card .error{ color:#c00; margin-top:8px; min-height: 1.2em; }

    @media (max-width: 420px){
      #paletteBar{ grid-template-columns: 1fr; }
      .dockZoom{ flex-direction: row; }
    }
    @media (max-width: 480px){
      :root{ --gap: 6px; }
      body{ margin: 12px; }
      .dockZoom button{ width: 32px; height: 26px; font-size: 15px; }
    }

    #pseudoMenuModal .modal-card ul > li > button{ width: 100%; padding: 10px 12px; border-radius: 8px; border: 1px solid #bbb; background: #fff; cursor: pointer; }
    #pseudoMenuModal .modal-card ul > li[style*="grid-template-columns"] > button{ width: 42px; height: 36px; padding: 0; font-size: 20px; line-height: 1; }

    /* — Règles (modal) — */
    .rules-overlay{ position: fixed; inset: 0; background: rgba(0,0,0,.55); display: none; align-items: center; justify-content: center; z-index: 9999; }
    .rules-modal{ width: min(560px, 92vw); background: #fff; color:#111; border-radius: 16px; box-shadow: 0 20px 60px rgba(0,0,0,.25); padding: 20px 20px 16px; border: 1px solid #ddd; }
    .rules-modal h2{ margin: 0 0 8px; font-size: 20px; }
    .rules-modal p{ margin: 8px 0; line-height: 1.5; }
    .rules-actions{ display:flex; justify-content:flex-end; gap: 8px; margin-top: 14px; }
    .rules-ok{ appearance: none; border: 0; border-radius: 12px; padding: 10px 16px; font-weight: 600; background:#111; color:#fff; cursor:not-allowed; opacity:.6; }
    .rules-ok.enabled{ cursor:pointer; opacity:1; }
    .rules-count{ font-size: 12px; color:#666; margin-right:auto; align-self:center; }
    #trackerToggle.on{
    background:#1976d2;
    color:#fff;
    border-color:#1976d2;
}

  </style>
</head>
<body>
  <div class="titlebar">
    <h1>Le Grand Gribidouillage</h1>
    <button id="pseudoBtn" title="Options">Options</button>
  </div>

  <div class="ui" id="uiBar">
    <div>Prochain reset : <span id="countdown" class="dim">Pause</span></div>
    <div>Connectés : <span id="onlineCount" class="dim">0</span></div>
    <div>Pixels posés : <span id="clickCount" class="dim">0</span></div>
    <div>Coordonnées : <span id="coords" class="dim">—</span></div>
    <div class="zoomControls">
      <button id="zOut"  title="Zoom -">−</button>
      <div class="level" id="zLevel">100%</div>
      <button id="zIn"   title="Zoom +">+</button>
      <button id="zReset" title="Réinitialiser le zoom">Reset</button>
      <button id="trackerToggle" title="Activer/Désactiver le menu flottant Trackeur">Trackeur</button>
    </div>
    <label class="toggle" title="Afficher/masquer la grille">
      <input type="checkbox" id="showGridChk"> Grille
    </label>
  </div>

  <div id="viewport">
    <div id="space">
      <div id="sizer"></div>
      <div id="stageWrap">
        <canvas id="board"></canvas>
      </div>
    </div>
  </div>

  <aside id="paletteBar" aria-label="Palette de couleurs">
    <div id="paletteGrid" aria-label="Couleurs"></div>
    <div class="dockZoom">
      <button id="dockZIn"  title="Zoom +">+</button>
      <button id="dockZOut" title="Zoom -">−</button>
    </div>
  </aside>

  <div id="trackerTip" role="status" aria-live="polite">
    <span class="xy">(—, —)</span>
    <span class="meta"></span>
  </div>

  <!-- Modals -->
  <div id="pseudoMenuModal" class="modal" hidden>
    <div class="modal-backdrop"></div>
    <div class="modal-card">
      <h2>Options</h2>
      <ul style="list-style:none; margin:10px 0 0 0; padding:0; display:flex; flex-direction:column; gap:10px;">
        <li><button id="menuChangePseudo">Changer pseudo</button></li>
        <li><button id="menuDownloadPNG">Télécharger PNG</button></li>
        <li style="display:grid; grid-template-columns:auto 1fr auto; align-items:center; gap:12px;">
          <button id="uiSizeMinus" title="Menu plus petit" aria-label="Réduire Menu">−</button>
          <span style="text-align:center; font-weight:600;">Menu</span>
          <button id="uiSizePlus" title="Menu plus grand" aria-label="Agrandir Menu">+</button>
        </li>
        <li style="display:grid; grid-template-columns:auto 1fr auto; align-items:center; gap:12px;">
          <button id="palSizeMinus" title="Palette plus petite" aria-label="Réduire Palette">−</button>
          <span style="text-align:center; font-weight:600;">Palette</span>
          <button id="palSizePlus" title="Palette plus grande" aria-label="Agrandir Palette">+</button>
        </li>
        <li><button id="menuOpenAdmin">Admin</button></li>
      </ul>
      <div class="modal-actions" style="justify-content:flex-end">
        <button id="menuClose">Fermer</button>
      </div>
    </div>
  </div>

  <div id="pseudoModal" class="modal" hidden>
    <div class="modal-backdrop"></div>
    <div class="modal-card">
      <h2>Choisir un pseudo</h2>
      <p class="hint">3–20 caractères, lettres/chiffres/underscore. Unique.</p>
      <input id="pseudoInput" type="text" placeholder="MonPseudo" maxlength="20" />
      <div class="modal-actions">
        <button id="pseudoSave">Enregistrer</button>
        <button id="pseudoCancel">Annuler</button>
      </div>
      <p id="pseudoError" class="error" aria-live="polite"></p>
    </div>
  </div>

  <!-- Firebase SDK (compat) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js" crossorigin="anonymous"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js" crossorigin="anonymous"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js" crossorigin="anonymous"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-storage-compat.js" crossorigin="anonymous"></script>

  <!-- 1) Config + init Firebase -->
  <script>
  /* === Diagnostics erreurs visibles === */
  window.addEventListener('error', (e)=>console.error('[window.error]', e.message, e.error||'')); 
  window.addEventListener('unhandledrejection', (e)=>console.error('[unhandledrejection]', e.reason||'')); 
  (function bootErrorBanner(){
    const bar = document.createElement('div');
    bar.style.cssText = "position:fixed;left:0;right:0;top:0;z-index:99999;display:none;background:#b00020;color:#fff;font:12px/1.3 system-ui, sans-serif;padding:6px 10px;white-space:pre-wrap";
    document.addEventListener('DOMContentLoaded', ()=> document.body.appendChild(bar));
    function show(msg){ bar.textContent = "Erreur JS : " + msg; bar.style.display = 'block'; }
    window.addEventListener('error', e => show(e.message || String(e)));
    window.addEventListener('unhandledrejection', e => show((e.reason && e.reason.message) || String(e.reason || e)));
  })();

  /* === Firebase config === */
  const firebaseConfig = {
    apiKey: "AIzaSyCxWxz9Nf97tBwIilvCgqQ7yVk3gMPC4Cs",
    authDomain: "le-grand-gribidouillage.firebaseapp.com",
    databaseURL: "https://le-grand-gribidouillage-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "le-grand-gribidouillage",
    storageBucket: "le-grand-gribidouillage.appspot.com", /* ✅ corrigé */
    messagingSenderId: "999048366927",
    appId: "1:999048366927:web:1120aca9e541873a93d33a"
  };
  firebase.initializeApp(firebaseConfig);

  const auth = firebase.auth();
  const db   = firebase.database();
  let storage = null;
  try { storage = firebase.storage(); } catch(e){ console.warn('Storage non init :', e); }
  </script>

  <!-- 2) Menu Options & Pseudo (UI) -->
  <script>
  // === Menu Options & Pseudo (UI) ===
  const pseudoBtn        = document.getElementById('pseudoBtn');
  const pseudoMenuModal  = document.getElementById('pseudoMenuModal');
  const menuChangePseudo = document.getElementById('menuChangePseudo');
  const menuOpenAdmin    = document.getElementById('menuOpenAdmin');
  const ADMIN_URL = new URL('./admin.html', location.href).toString();
  const menuClose        = document.getElementById('menuClose');
  const menuDownloadPNG = document.getElementById('menuDownloadPNG');
    
  const pseudoModal  = document.getElementById('pseudoModal');
  const pseudoInput  = document.getElementById('pseudoInput');
  const pseudoSave   = document.getElementById('pseudoSave');
  const pseudoCancel = document.getElementById('pseudoCancel');
  const pseudoError  = document.getElementById('pseudoError');

  function openPseudoMenu(){ pseudoMenuModal.hidden = false; }
  function closePseudoMenu(){ pseudoMenuModal.hidden = true; }
  function openPseudoModal(){ pseudoError.textContent=''; pseudoModal.hidden = false; setTimeout(()=>pseudoInput.focus(),0); }
  function closePseudoModal(){ pseudoModal.hidden = true; }

  pseudoBtn.addEventListener('click', openPseudoMenu);
  menuClose.addEventListener('click', closePseudoMenu);
  pseudoMenuModal.querySelector('.modal-backdrop').addEventListener('click', closePseudoMenu);
  menuChangePseudo.addEventListener('click', ()=>{ closePseudoMenu(); openPseudoModal(); });
  menuOpenAdmin.addEventListener('click', ()=> window.open(ADMIN_URL, '_blank', 'noopener'));
  pseudoCancel.addEventListener('click', closePseudoModal);

  // --- Rendu offscreen SANS grille, puis export PNG net ---
function renderBoardOffscreen(scale = 4){
  // scale = 4 => 1200×1200 si 300×300 logiques et PIX=1 (ici PIX est la taille de cellule en px écran)
  const cell = PIX * scale;
  const off = document.createElement('canvas');
  off.width  = W * cell;
  off.height = H * cell;
  const octx = off.getContext('2d');
  octx.imageSmoothingEnabled = false;

  // Peint chaque cellule depuis notre "grid" mémoire, SANS overlay de grille
  for (let y = 0; y < H; y++){
    for (let x = 0; x < W; x++){
      const idx = grid[y][x] | 0;
      octx.fillStyle = colors[idx] || '#FFFFFF';
      octx.fillRect(x * cell, y * cell, cell, cell);
    }
  }
  return off;
}

function downloadBoardPNG(scale = 4){
  try{
    const off = renderBoardOffscreen(scale); // <-- pas de grille ici
    const save = (url) => {
      const a = document.createElement('a');
      a.href = url;
      a.download = `gribidouillage_${Date.now()}_x${scale}.png`;
      document.body.appendChild(a); a.click(); a.remove();
    };

    if (off.toBlob){
      off.toBlob((blob)=>{
        if (!blob) return save(off.toDataURL('image/png'));
        const url = URL.createObjectURL(blob);
        save(url);
        setTimeout(()=> URL.revokeObjectURL(url), 2000);
      }, 'image/png');
    } else {
      save(off.toDataURL('image/png'));
    }
  } catch(e){
    console.error('[downloadBoardPNG]', e);
    alert('Export PNG impossible (voir console).');
  }
}

// Bouton du menu Options
menuDownloadPNG.addEventListener('click', ()=>{
  closePseudoMenu();
  downloadBoardPNG(4); // PNG net x4
});

 
    
  let CURRENT_UID = null;
  let myName = localStorage.getItem('nickname') || null;
  function updatePseudoBtn(){ pseudoBtn.textContent = 'Options'; }

  // Auth anonyme + chargement du pseudo
  auth.signInAnonymously().catch(console.error);
  auth.onAuthStateChanged(async (user)=>{
    if (!user) return;
    CURRENT_UID = user.uid;
    updatePseudoBtn();
    // Signale que l'UID est dispo (pour la présence)
    document.dispatchEvent(new CustomEvent('auth:ready'));

    try {
      const s = await db.ref(`users/${CURRENT_UID}/name`).once('value');
      const n = s.val();
      if (n) {
        myName = n; localStorage.setItem('nickname', n);
      } else {
        openPseudoModal();
      }
    } catch (_) {
      if (!myName) openPseudoModal();
    }
  });

  // Helpers pseudo
  function normalizeName(s){ return s.trim(); }
  function toKey(s){ return s.toLowerCase().replace(/[^a-z0-9_]/g,''); }
  function isValidName(s){ return /^[A-Za-z0-9_]{3,20}$/.test(s); }

  async function savePseudo(){
    const raw = normalizeName(pseudoInput.value);
    if (!isValidName(raw)){ pseudoError.textContent = "Pseudo invalide (3–20 caractères alphanumériques ou underscore)."; return; }
    if (!CURRENT_UID){ pseudoError.textContent = "Connexion en cours…"; return; }

    const key = toKey(raw);
    const refClaim = db.ref(`users_by_name/${key}`);
    const tx = await refClaim.transaction(cur => (cur === null || cur === CURRENT_UID) ? CURRENT_UID : undefined);
    if (!tx.committed || tx.snapshot.val() !== CURRENT_UID){
      pseudoError.textContent = "Ce pseudo est déjà pris.";
      return;
    }

    await db.ref(`users/${CURRENT_UID}/name`).set(raw);
    myName = raw;
    localStorage.setItem('nickname', raw);
    closePseudoModal();
    document.dispatchEvent(new CustomEvent('pseudo:chosen'));
  }
  pseudoSave.addEventListener('click', savePseudo);
  pseudoInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') savePseudo(); });
  </script>

  <!-- 3) Palette / grille / zoom / layout -->
  <script>
  /* ----- Palette, grille, layout, listeners... ----- */

  /* Paramètres mosaïque */
  const IS_MOBILE = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
  const W = 300, H = 300;
  let PIX = IS_MOBILE ? 8 : 10;
  const canvas = document.getElementById('board');
  canvas.width  = W * PIX;
  canvas.height = H * PIX;
  const ctx = canvas.getContext('2d');
  let _canvasRect = null;
  function measureCanvasRect(){ _canvasRect = canvas.getBoundingClientRect(); }

  /* Palette couleurs */
  const colors = [
    '#000000','#FFFFFF','#2F2F2F','#808080','#D3D3D3',
    '#B22222','#FF0000','#FFC0CB',
    '#8B4513','#FF7F00','#FFDAB9',
    '#FFD700','#FFFF00','#FFFACD',
    '#006400','#00FF00','#ADFF2F',
    '#008080','#40E0D0','#00FFFF',
    '#000080','#0000FF','#87CEEB',
    '#4B0082','#8A2BE2','#BA55D3','#E0B0FF',
    '#FF00FF'
  ];
  const PALETTE_ORDER = [0,2,3,4,1,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27];

  let selected = 0;
  let selectedIsEraser = false;

  const viewport   = document.getElementById('viewport');
  const sizer      = document.getElementById('sizer');
  const stageWrap  = document.getElementById('stageWrap');
  const paletteGrid= document.getElementById('paletteGrid');
  const paletteBar = document.getElementById('paletteBar');
  const uiBar      = document.getElementById('uiBar');
  const countdownEl= document.getElementById('countdown');
  const onlineEl   = document.getElementById('onlineCount');
  const clickEl    = document.getElementById('clickCount');
  const coordsEl   = document.getElementById('coords');
  const zLevelEl   = document.getElementById('zLevel');
  const showGridChk= document.getElementById('showGridChk');
  const trackerToggle = document.getElementById('trackerToggle');
  const trackerTip = document.getElementById('trackerTip');
  const palSizeMinus = document.getElementById('palSizeMinus');
  const palSizePlus  = document.getElementById('palSizePlus');
  const uiSizeMinus  = document.getElementById('uiSizeMinus');
  const uiSizePlus   = document.getElementById('uiSizePlus');
  const trackerXY  = trackerTip.querySelector('.xy');
  const trackerMeta= trackerTip.querySelector('.meta');
    // Cache pseudo par UID
const nameCache = new Map();
function uidShort(u){ return (u||'').slice(0,6) || '—'; }
function getPseudo(uid){
  if (!uid) return Promise.resolve('—');
  if (nameCache.has(uid)) return Promise.resolve(nameCache.get(uid));
  return db.ref(`users/${uid}/name`).once('value').then(s=>{
    const n = s.val();
    const name = (typeof n === 'string' && n.trim()) ? n.trim() : uidShort(uid);
    nameCache.set(uid, name);
    return name;
  }).catch(()=> uidShort(uid));
}
    let trackerEnabled = false;

function setTracker(on){
  trackerEnabled = !!on;
  trackerTip.style.display = trackerEnabled ? 'block' : 'none';
  trackerToggle.classList.toggle('on', trackerEnabled);
  trackerToggle.setAttribute('aria-pressed', trackerEnabled ? 'true' : 'false');
}


trackerToggle.addEventListener('click', ()=>{
  setTracker(!trackerEnabled);
});
    
let _hoverLastX = -1, _hoverLastY = -1, _hoverLastUID = null;

canvas.addEventListener('mousemove', (e)=>{
  const rect = _canvasRect || canvas.getBoundingClientRect();
  const localX = (e.clientX - rect.left) / zoom;
  const localY = (e.clientY - rect.top)  / zoom;
  const x = Math.floor(localX / PIX), y = Math.floor(localY / PIX);

  if (x>=0 && x<W && y>=0 && y<H) {
    // si même cellule qu'à la frame précédente, on ne refait rien de lourd
    if (x === _hoverLastX && y === _hoverLastY){
      if (trackerEnabled){
        trackerTip.style.left = `${e.clientX}px`;
        trackerTip.style.top  = `${e.clientY - 12}px`;
      }
      return;
    }
    _hoverLastX = x; _hoverLastY = y;

    coordsEl.textContent = `(${x}, ${y})`;
    if (trackerEnabled){
      trackerXY.textContent = `(${x}, ${y})`;
      const uid = authorGrid[y][x] || null;

      // Ne résout le pseudo QUE si l’UID change
      if (uid !== _hoverLastUID){
        _hoverLastUID = uid;
        getPseudo(uid).then(name=>{
          // sécurité : ne change le texte que si on est toujours sur la même cellule
          if (x === _hoverLastX && y === _hoverLastY) {
            trackerMeta.textContent = name;
          }
        });
      }

      trackerTip.style.left = `${e.clientX}px`;
      trackerTip.style.top  = `${e.clientY - 12}px`;
      trackerTip.style.display = 'block';
    }
  } else {
    coordsEl.textContent = '—';
    if (trackerEnabled) trackerTip.style.display = 'none';
  }
});

canvas.addEventListener('mouseleave', ()=>{
  // reset du cache hover pour stopper toute résolution de pseudo en cours
  _hoverLastX = -1;
  _hoverLastY = -1;
  _hoverLastUID = null;

  coordsEl.textContent = '—';
  if (trackerEnabled) trackerTip.style.display = 'none';
});

canvas.addEventListener('mouseenter', ()=>{
  if (trackerEnabled) trackerTip.style.display = 'block';
});



  const SCALE_STEPS = [0.75, 1, 1.25];
  function clampIndex(i){ return Math.max(0, Math.min(SCALE_STEPS.length-1, i)); }

  /* Grid mémoire */
  let grid = Array.from({length:H}, ()=>Array.from({length:W}, ()=>1));
  const authorGrid = Array.from({length:H}, ()=>Array.from({length:W}, ()=>null));
  const tsGrid     = Array.from({length:H}, ()=>Array.from({length:W}, ()=>null));

  function drawCell(x,y){ ctx.fillStyle = colors[grid[y][x]]; ctx.fillRect(x*PIX, y*PIX, PIX, PIX); }
  function fullPixels(){ for (let y=0;y<H;y++) for (let x=0;x<W;x++) drawCell(x,y); }

  /* Grille overlay */
  let gridOverlayCache = null;
  function makeGridOverlay(){
    const oc = document.createElement('canvas');
    oc.width = canvas.width; oc.height = canvas.height;
    const octx = oc.getContext('2d');
    const thin = 'rgba(0,0,0,0.15)', bold = 'rgba(0,0,0,0.35)';
    octx.save(); octx.lineWidth = 1;

    octx.beginPath(); octx.strokeStyle = thin;
    for (let x=0; x<=W; x++){
      const xx = x*PIX + 0.5;
      if (x % 10 === 0){ octx.stroke(); octx.beginPath(); octx.strokeStyle = bold; octx.moveTo(xx, 0); octx.lineTo(xx, H*PIX); octx.stroke(); octx.beginPath(); octx.strokeStyle = thin; }
      else { octx.moveTo(xx, 0); octx.lineTo(xx, H*PIX); }
    }
    octx.stroke();

    octx.beginPath(); octx.strokeStyle = thin;
    for (let y=0; y<=H; y++){
      const yy = y*PIX + 0.5;
      if (y % 10 === 0){ octx.stroke(); octx.beginPath(); octx.strokeStyle = bold; octx.moveTo(0, yy); octx.lineTo(W*PIX, yy); octx.stroke(); octx.beginPath(); octx.strokeStyle = thin; }
      else { octx.moveTo(0, yy); octx.lineTo(W*PIX, yy); }
    }
    octx.stroke();
    octx.restore();
    return oc;
  }
  function drawGridOverlay(){ if (!gridOverlayCache) gridOverlayCache = makeGridOverlay(); ctx.drawImage(gridOverlayCache, 0, 0); }

  /* Curseurs */
  function makeColorCursor(hex, size = 22) {
    const r = Math.floor(size/2) - 2;
    const svg =
      `<svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}'>` +
        `<circle cx='${size/2}' cy='${size/2}' r='${r}' fill='${hex}'/>` +
        `<circle cx='${size/2}' cy='${size/2}' r='${r-0.5}' fill='none' stroke='white' stroke-width='2'/>` +
        `<circle cx='${size/2}' cy='${size/2}' r='${r-2.5}' fill='none' stroke='black' stroke-width='1.5'/>` +
      `</svg>`;
    return `url("data:image/svg+xml;utf8,${encodeURIComponent(svg)}") ${Math.floor(size/2)} ${Math.floor(size/2)}, crosshair`;
  }
  function makeEraserCursor(size = 22){
    const r = Math.floor(size/2) - 2;
    const svg =
      `<svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}'>` +
        `<defs><pattern id='chk' width='6' height='6' patternUnits='userSpaceOnUse'>` +
          `<rect width='6' height='6' fill='#fff'/><path d='M0,0 L6,6 M-3,3 L3,9 M3,-3 L9,3' stroke='#ddd'/>` +
        `</pattern></defs>` +
        `<circle cx='${size/2}' cy='${size/2}' r='${r}' fill='url(#chk)' stroke='#999' stroke-width='2'/>` +
        `<line x1='4' y1='4' x2='${size-4}' y2='${size-4}' stroke='#b00' stroke-width='2'/>` +
      `</svg>`;
    return `url("data:image/svg+xml;utf8,${encodeURIComponent(svg)}") ${Math.floor(size/2)} ${Math.floor(size/2)}, crosshair`;
  }
  function updateCursor(){ canvas.style.cursor = selectedIsEraser ? makeEraserCursor() : makeColorCursor(colors[selected]); }
  canvas.addEventListener('mouseenter', updateCursor);
  canvas.addEventListener('mouseleave', ()=>{ canvas.style.cursor = 'default'; coordsEl.textContent = '—'; trackerTip.style.display='none'; });

  /* Palette UI */
  function buildPalette(){
    paletteGrid.innerHTML = '';
    PALETTE_ORDER.forEach((idx)=>{
      const sw = document.createElement('div');
      sw.className = 'sw';
      if (idx === 1) {
        sw.title = 'Gomme — effacer le pixel';
        sw.style.background = '#FFFFFF';
        if (selectedIsEraser) sw.classList.add('activeSw');
        sw.onclick = ()=>{
          selected = 1; selectedIsEraser = true;
          [...paletteGrid.children].forEach(el => el.classList.remove('activeSw'));
          sw.classList.add('activeSw'); updateCursor();
        };
      } else {
        const hex = colors[idx];
        sw.style.background = hex;
        sw.title = hex;
        if (!selectedIsEraser && idx === selected) sw.classList.add('activeSw');
        sw.onclick = ()=>{
          selected = idx; selectedIsEraser = (idx === 1);
          [...paletteGrid.children].forEach(el => el.classList.remove('activeSw'));
          sw.classList.add('activeSw'); updateCursor();
        };
      }
      paletteGrid.appendChild(sw);
    });
  }

  /* Échelles UI */
  let _vp_lastTop = '', _vp_lastBottom = '';
  function layoutViewport(){
    const uiBottom = uiBar.getBoundingClientRect().bottom;
    const palTop   = paletteBar.getBoundingClientRect().top;
    const rootCS  = getComputedStyle(document.documentElement);
    const safeBtm = parseFloat(rootCS.getPropertyValue('--safe-bottom')) || 0;
    const newTop = Math.round(uiBottom + 8) + 'px';
    let bottomSpace = Math.round(Math.max(0, window.innerHeight - palTop) + 8 + safeBtm);
    if (!Number.isFinite(bottomSpace) || bottomSpace <= 0){
      const barHVar = parseFloat(rootCS.getPropertyValue('--bar-h')) || 92;
      bottomSpace = Math.round(barHVar + 8 + safeBtm);
    }
    const newBottom = bottomSpace + 'px';
    if (newTop !== _vp_lastTop){ viewport.style.top = newTop; _vp_lastTop = newTop; }
    if (newBottom !== _vp_lastBottom){ viewport.style.bottom = newBottom; _vp_lastBottom = newBottom; }
  }

  /* Palette responsive 2 rangées */
  let _pal_lastW=-1,_pal_lastCols=-1,_pal_lastSW=-1,_pal_lastBarH=-1;
  function layoutPaletteTwoRows(){
    const total = colors.length;
    const cols = Math.ceil(total / 2);
    const bar  = paletteBar;
    const btns = bar.querySelector('.dockZoom');
    const barW  = bar.clientWidth;
    const btnW  = btns ? btns.offsetWidth : 0;
    if (Math.abs(barW - _pal_lastW) < 1 && cols === _pal_lastCols) return;

    const rootCS = getComputedStyle(document.documentElement);
    const barCS  = getComputedStyle(bar);
    const padX = parseFloat(barCS.paddingLeft) + parseFloat(barCS.paddingRight);
    const padY = parseFloat(barCS.paddingTop)  + parseFloat(barCS.paddingBottom);
    const gap = parseFloat(rootCS.getPropertyValue('--gap')) || 8;
    const available = Math.max(120, barW - btnW - 10 - padX);
    const sw = Math.floor((available - gap * (cols - 1)) / cols);
    const minSw = 18, maxSw = IS_MOBILE ? 28 : 32;
    const clamped = Math.max(minSw, Math.min(maxSw, sw));
    const barH = Math.ceil((clamped * 2) + gap + padY);

    if (cols !== _pal_lastCols) { bar.style.setProperty('--cols', String(cols)); _pal_lastCols = cols; }
    if (clamped !== _pal_lastSW) { bar.style.setProperty('--sw', clamped + 'px'); _pal_lastSW = clamped; }
    if (barH !== _pal_lastBarH) { document.documentElement.style.setProperty('--bar-h', barH + 'px'); _pal_lastBarH = barH; }
    _pal_lastW = barW;
  }

  /* Zoom & layout */
  let _sizer_w=-1,_sizer_h=-1;
  function updateSizer(){
    const scaledW = Math.ceil(W * PIX * zoom);
    const scaledH = Math.ceil(H * PIX * zoom);
    if (scaledW !== _sizer_w) { sizer.style.width  = scaledW + 'px'; _sizer_w = scaledW; }
    if (scaledH !== _sizer_h) { sizer.style.height = scaledH + 'px'; _sizer_h = scaledH; }
  }
  function clampScroll(){
    const maxLeft = Math.max(0, sizer.offsetWidth  - viewport.clientWidth );
    const maxTop  = Math.max(0, sizer.offsetHeight - viewport.clientHeight);
    if (viewport.scrollLeft < 0) viewport.scrollLeft = 0;
    else if (viewport.scrollLeft > maxLeft) viewport.scrollLeft = maxLeft;
    if (viewport.scrollTop < 0) viewport.scrollTop = 0;
    else if (viewport.scrollTop > maxTop) viewport.scrollTop = maxTop;
  }
  var layoutScheduled=false, isLayingOut=false, _ro=null;
  function scheduleRelayout(){
    if (layoutScheduled) return;
    layoutScheduled = true;
    requestAnimationFrame(()=>{
      layoutScheduled = false; isLayingOut = true;
      try { layoutPaletteTwoRows(); layoutViewport(); updateSizer(); clampScroll(); measureCanvasRect(); }
      catch(e){ console.error('[scheduleRelayout]', e); }
      finally { isLayingOut = false; }
    });
  }

  let zoom = 1; const ZOOM_MIN=0.25, ZOOM_MAX=4, ZOOM_STEP=1.12;
  function clampZoom(z){ return Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, z)); }
  function applyZoom(){ stageWrap.style.transform = `scale(${zoom})`; zLevelEl.textContent = `${Math.round(zoom*100)}%`; updateSizer(); requestAnimationFrame(measureCanvasRect); }
  function setZoomAroundPoint(newZoom, pxClient, pyClient){
    const vp = viewport; const rect = vp.getBoundingClientRect();
    const logicalX = (vp.scrollLeft + (pxClient - rect.left)) / zoom;
    const logicalY = (vp.scrollTop  + (pyClient - rect.top )) / zoom;
    zoom = clampZoom(newZoom); applyZoom();
    vp.scrollLeft = logicalX * zoom - (pxClient - rect.left);
    vp.scrollTop  = logicalY * zoom - (pyClient - rect.top);
    clampScroll();
  }
  function zoomIn(){ const r=viewport.getBoundingClientRect(); setZoomAroundPoint(clampZoom(zoom * ZOOM_STEP), r.left+r.width/2, r.top+r.height/2); }
  function zoomOut(){ const r=viewport.getBoundingClientRect(); setZoomAroundPoint(clampZoom(zoom / ZOOM_STEP), r.left+r.width/2, r.top+r.height/2); }
  document.getElementById('zIn').onclick = zoomIn;
  document.getElementById('zOut').onclick = zoomOut;
  document.getElementById('zReset').onclick = ()=>{ zoom = 1; applyZoom(); clampScroll(); };
  document.getElementById('dockZIn').onclick  = zoomIn;
  document.getElementById('dockZOut').onclick = zoomOut;
    /* ===== Pinch-to-zoom (deux doigts) =====
   - 1 doigt : on laisse le scroll natif du #viewport
   - 2 doigts : pinch custom qui appelle setZoomAroundPoint()
*/
(function enablePinch(){
  const ptrs = new Map();   // id -> {x,y}
  let pinch = null;         // {startDist, baseZoom}

  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function center(a,b){ return { x: (a.x+b.x)/2, y:(a.y+b.y)/2 }; }

  function onDown(e){
    if (e.pointerType !== 'touch') return;      // souris/pen : on ignore
    viewport.setPointerCapture(e.pointerId);
    ptrs.set(e.pointerId, { x:e.clientX, y:e.clientY });

    if (ptrs.size === 2){
      // on initialise le pinch
      const [p1, p2] = [...ptrs.values()];
      pinch = {
        startDist: dist(p1,p2),
        baseZoom: zoom
      };
      // Évite que le navigateur tente un scroll pendant le pinch
      e.preventDefault();
    }
  }

  function onMove(e){
    if (!ptrs.has(e.pointerId)) return;
    if (e.pointerType !== 'touch') return;

    ptrs.set(e.pointerId, { x:e.clientX, y:e.clientY });

    // S’il y a deux doigts actifs, on calcule l’échelle et on zoome autour du centre des doigts
    if (ptrs.size === 2 && pinch){
      const [p1, p2] = [...ptrs.values()];
      const d = dist(p1,p2);
      if (pinch.startDist > 0){
        const scale = d / pinch.startDist;
        const newZ = clampZoom(pinch.baseZoom * scale);
        const c = center(p1,p2);
        setZoomAroundPoint(newZ, c.x, c.y);
      }
      e.preventDefault(); // bloque le scroll pendant le pinch
    }
  }

  function onUpOrCancel(e){
    if (ptrs.has(e.pointerId)){
      ptrs.delete(e.pointerId);
    }
    if (ptrs.size < 2){
      pinch = null; // fin de geste
    }
  }

  // Important : listeners non-passifs pour pouvoir preventDefault() pendant le pinch
  viewport.addEventListener('pointerdown', onDown, { passive:false });
  viewport.addEventListener('pointermove', onMove,  { passive:false });
  viewport.addEventListener('pointerup', onUpOrCancel, { passive:false });
  viewport.addEventListener('pointercancel', onUpOrCancel, { passive:false });
})();

    /* ===== Pinch sur trackpad (Ctrl/⌘ + molette) + Safari gestures ===== */
(function enableTrackpadPinch(){
  // — Ctrl/⌘ + wheel → zoom autour du pointeur (Chrome/Edge/Firefox)
  const WHEEL_SENS = 0.0025; // plus petit = zoom plus doux

  function onWheel(e){
    // La plupart des OS déclenchent ctrlKey pendant un pinch trackpad
    if (Math.abs(e.deltaY) < 0.2) return;
    if (!(e.ctrlKey || e.metaKey)) return;
    if (e.deltaY === 0) return;

    e.preventDefault(); // empêche le zoom navigateur et le scroll
    // Exponentiel lissé (insensible au deltaMode)
    const scale = Math.exp(-e.deltaY * WHEEL_SENS);
    const newZ  = clampZoom(zoom * scale);
    setZoomAroundPoint(newZ, e.clientX, e.clientY);
  }

  viewport.addEventListener('wheel', onWheel, { passive:false });

  // — Safari : événements non standards gesturestart/gesturechange
  let safariBaseZoom = 1;

  function onGestureStart(e){
    safariBaseZoom = zoom;
    e.preventDefault();
  }
  function onGestureChange(e){
    // e.scale est relatif au gesturestart
    const newZ = clampZoom(safariBaseZoom * e.scale);
    // Safari ne donne pas le centre → on zoome autour du centre du viewport
    const r = viewport.getBoundingClientRect();
    setZoomAroundPoint(newZ, r.left + r.width/2, r.top + r.height/2);
    e.preventDefault();
  }

  window.addEventListener('gesturestart',  onGestureStart,  { passive:false });
  window.addEventListener('gesturechange', onGestureChange, { passive:false });
})();



  /* État palette & layout init */
  buildPalette();
  updateCursor();
  window.addEventListener('load', ()=>{ applyZoom(); scheduleRelayout(); });
  window.addEventListener('resize', scheduleRelayout);
  window.addEventListener('orientationchange', ()=>{ setTimeout(scheduleRelayout, 200); });

  /* Grille initiale + affichage */
  fullPixels();
  if (localStorage.getItem('pw-show-grid') === '1') { showGridChk.checked = true; drawGridOverlay(); }
  else { showGridChk.checked = false; }
  showGridChk.addEventListener('change', ()=>{ localStorage.setItem('pw-show-grid', showGridChk.checked ? '1' : '0'); fullPixels(); if (showGridChk.checked) drawGridOverlay(); });

  document.getElementById('countdown').innerHTML = '<span style="color:#b00020;font-weight:700">Ce soir&nbsp;Minuit</span>';
  </script>

  <!-- 4) Pixels (RTDB) minimal -->
  <script>
  // === Pixels (RTDB) minimal ===
  const pixelsRef = db.ref('pixels');
  const clicksRef = db.ref('stats/clicksTotal');
clicksRef.on('value', (snap)=>{
  const n = snap.val();
  clickEl.textContent = Number.isFinite(n) ? n : 0;
});
    // === Présence (nombre de connectés) ===
const connectedRef = db.ref('.info/connected');

function ensurePresenceBinding(){
  if (!CURRENT_UID) return; // on attend l’auth anonyme
  const userPresenceRef = db.ref(`presence/${CURRENT_UID}`);

  connectedRef.on('value', (snap)=>{
    if (snap.val() === true) {
      // A la déco → supprime le nœud (OK avec tes règles)
      userPresenceRef.onDisconnect().remove().catch(err=>{
        console.error('[presence.onDisconnect.remove] rules?', err);
      });

      // En ligne → DOIT respecter la validation: { online:boolean, ts:number }
      userPresenceRef.set({
        online: true,
        ts: firebase.database.ServerValue.TIMESTAMP
      }).catch(err=>{
        console.error('[presence.set] rules?', err);
      });

      // (optionnel) dernière vue pour l’admin
      db.ref(`users/${CURRENT_UID}/lastSeen`).set(firebase.database.ServerValue.TIMESTAMP)
        .catch(()=>{});
    }
  });

  // Afficher le nombre de connectés
  db.ref('presence').on('value', (snap)=>{
    onlineEl.textContent = snap.numChildren();
  });
}


// Quand l’auth est prête, on attache la présence (on a CURRENT_UID dans onAuthStateChanged)
document.addEventListener('auth:ready', ensurePresenceBinding);

 // Rendu initial des pixels (+ auteurs + timestamps)
pixelsRef.once('value').then(snap=>{
  const val = snap.val() || {};
  for (let y=0; y<H; y++){
    for (let x=0; x<W; x++){
      const k = `${x}_${y}`;
      const v = val[k] || {};
      const idx = (Number.isFinite(+v.color)) ? +v.color : 1; // 1 = blanc
      grid[y][x]       = idx;
      authorGrid[y][x] = v.author || null;
      tsGrid[y][x]     = Number.isFinite(+v.ts) ? +v.ts : null;
    }
  }
  fullPixels();
  if (showGridChk.checked) drawGridOverlay();
});


  function onPixelUpdate(snap){
  const [x,y] = snap.key.split('_').map(Number);
  const v = snap.val() || {};
  const col = Number.isFinite(+v.color) ? +v.color : 1;
  if (x>=0 && x<W && y>=0 && y<H) {
    grid[y][x]       = col;
    authorGrid[y][x] = v.author || null;
    tsGrid[y][x]     = Number.isFinite(+v.ts) ? +v.ts : null;
    drawCell(x,y);
    scheduleGridOverlay();
  }
}
function onPixelRemoved(snap){
  const [x,y] = snap.key.split('_').map(Number);
  if (x>=0 && x<W && y>=0 && y<H){
    grid[y][x]       = 1;      // blanc
    authorGrid[y][x] = null;
    tsGrid[y][x]     = null;
    drawCell(x,y);
    scheduleGridOverlay();
  }
}

  pixelsRef.on('child_added', onPixelUpdate);
  pixelsRef.on('child_changed', onPixelUpdate);
  pixelsRef.on('child_removed', onPixelRemoved);

  // Click sur le canvas → écrit un pixel
  function writePixel(x,y,idx){
    const key = `${x}_${y}`;
    const payload = { color: idx, author: CURRENT_UID || 'anon', ts: firebase.database.ServerValue.TIMESTAMP };
    return db.ref(`pixels/${key}`).set(payload)
      .then(()=> clicksRef.set(firebase.database.ServerValue.increment(1)));
  }

  const canvas2 = document.getElementById('board');
  canvas2.addEventListener('click', (e)=>{
    if (!localStorage.getItem('nickname')){ 
      // Si pas de pseudo → ouvrir la modale
      document.getElementById('pseudoMenuModal').hidden = true;
      document.getElementById('pseudoModal').hidden = false;
      return;
    }
    const rect = canvas2.getBoundingClientRect();
    const localX = (e.clientX - rect.left) / zoom;
    const localY = (e.clientY - rect.top)  / zoom;
    const x = Math.floor(localX / PIX), y = Math.floor(localY / PIX);
    if (x<0||x>=W||y<0||y>=H) return;
    const idx = selectedIsEraser ? 1 : selected;
    writePixel(x,y,idx).catch(console.error);
  });
  </script>

  <!-- Fenêtre Règles -->
  <div id="rulesOverlay" class="rules-overlay" aria-modal="true" role="dialog" aria-labelledby="rulesTitle" aria-hidden="true">
    <div class="rules-modal">
      <h2 id="rulesTitle">Règles</h2>
      <p>Toute représentation offensante, violente ou à caractère sexuel sera suivie d’un bannissement permanent du site.</p>
      <p>Merci de respecter les règles du vivre-ensemble pour faire de cet endroit un espace de création partagé agréable pour toutes et tous.</p>
      <div class="rules-actions">
        <span id="rulesCount" class="rules-count">OK disponible dans 10&nbsp;s</span>
        <button id="rulesOkBtn" class="rules-ok" disabled>OK</button>
      </div>
    </div>
  </div>

  <!-- 5) Logique modale Règles -->
  <script>
  (function(){
    const KEY_ACCEPT = 'rulesAcceptedV1';
    const overlay = document.getElementById('rulesOverlay');
    const okBtn   = document.getElementById('rulesOkBtn');
    const countEl = document.getElementById('rulesCount');
    let countdown = 10, timerId = null;

    function startCountdown(){ countdown = 10; updateCount(); okBtn.disabled = true; okBtn.classList.remove('enabled'); clearInterval(timerId);
      timerId = setInterval(()=>{ countdown--; updateCount(); if (countdown <= 0){ clearInterval(timerId); countEl.textContent=''; okBtn.disabled=false; okBtn.classList.add('enabled'); okBtn.focus(); } },1000); }
    function updateCount(){ countEl.textContent = `OK disponible dans ${countdown}\u00A0s`; }
    function showRules(){ if (sessionStorage.getItem(KEY_ACCEPT)) return; overlay.style.display='flex'; overlay.setAttribute('aria-hidden','false'); startCountdown(); document.addEventListener('keydown', blockEsc, { capture:true }); }
    function blockEsc(e){ if (e.key === 'Escape'){ e.preventDefault(); } }
    function acceptRules(){ if (okBtn.disabled) return; sessionStorage.setItem(KEY_ACCEPT,'1'); overlay.style.display='none'; overlay.setAttribute('aria-hidden','true'); document.removeEventListener('keydown', blockEsc, { capture:true }); }
    okBtn.addEventListener('click', acceptRules);

    function hasPseudoChosen(){ const nick = localStorage.getItem('nickname'); return !!(nick && nick.trim().length); }
    if (hasPseudoChosen()) showRules();
    document.addEventListener('pseudo:chosen', ()=>{ showRules(); }, { once:true });
    window.__showRulesAfterPseudo = showRules;
  })();
  </script>
</body>
</html>








