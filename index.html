<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <!-- Zoom natif désactivé ; pinch géré par l’app -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Le Grand Gribidouillage</title>
  <style>
    :root{
      --ui-scale: 1;
      --pal-scale: 1;
      --bar-h: 92px;
      --bar-pad: 10px;
      --gap: 8px;
      --sw: 28px;
      --cols: 14;
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-top: env(safe-area-inset-top, 0px);
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100dvh;
      min-height: 100dvh;
      height: -webkit-fill-available;
      overflow: hidden;
      background:#fff;
    }
    body { font-family: system-ui, sans-serif; margin: 16px; padding-bottom: var(--safe-bottom); }
    h1 { margin: 0; font-size: 18px; }
    .titlebar{ display:flex; align-items:center; gap:10px; margin-bottom:8px; flex-wrap: wrap; }
     .titlebar, #uiBar{
      transform: scale(var(--ui-scale));
      transform-origin: top left;}
    .ui { display:flex; gap:16px; align-items:center; margin-bottom:12px; flex-wrap: wrap; }
    .dim { opacity:.7 }

    #pseudoBtn{
      padding: 6px 10px;
      border:1px solid #aaa; border-radius:8px; background:#fff; cursor:pointer;
    }

    #viewport{
      position: fixed; left: 0; right: 0;
      overflow: auto; overscroll-behavior: contain;
      -webkit-overflow-scrolling: touch;
      touch-action: pan-x pan-y;
      background: #fff; z-index: 1;
      contain: size layout;
    }

    #space{ position: relative; }
    #sizer{ width: 1px; height: 1px; }

    #stageWrap{
      position: absolute; top: 0; left: 0;
      display:inline-block;
      transform-origin: top left;
      transition: transform 120ms ease-out;
      will-change: transform;
      contain: layout paint;
    }
    #board{ image-rendering: pixelated; border:1px solid #333; touch-action: manipulation; display:block; }

    #paletteBar{
      position: fixed; left: 50%;
      transform: translateX(-50%) scale(var(--pal-scale));
      transform-origin: bottom center;
      bottom: calc(8px + var(--safe-bottom));
      max-width: min(100vw - 16px, 1100px);
      padding: var(--bar-pad);
      border:1px solid #333; border-radius:14px; background:#fff;
      box-shadow: 0 6px 18px rgba(0,0,0,.14);
      display:grid; grid-template-columns: 1fr auto auto; align-items:center; gap:10px; z-index:10;
      contain: content;
      will-change: contents;
    }

    #paletteGrid{
      display:grid; grid-auto-flow: row dense;
      grid-template-columns: repeat(var(--cols), var(--sw));
      grid-auto-rows: var(--sw);
      row-gap: var(--gap); column-gap: var(--gap); place-items:center;
    }
    
    .sw{ width:var(--sw); height:var(--sw); border:1px solid #000; border-radius:6px; cursor:pointer; }
    .activeSw{ outline:2px solid #000; outline-offset:2px; }
    
    .dockZoom{ display:flex; flex-direction:column; gap:6px; align-items:center; justify-content:center; }
    .dockZoom button{ width:36px; height:28px; border:1px solid #aaa; border-radius:8px; background:#fff; cursor:pointer; font-size:16px; line-height:1; }
    .sizeControls{ display:flex; gap:6px; align-items:center; justify-content:center; }
    .sizeControls button{ width:36px; height:28px; border:1px solid #aaa; border-radius:8px; background:#fff; cursor:pointer; font-size:16px; line-height:1; }
    .zoomControls{ display:flex; gap:8px; align-items:center; }
    .zoomControls button{ cursor:pointer; padding:6px 10px; border:1px solid #aaa; border-radius:8px; background:#fff; }
    .zoomControls .level{ min-width:48px; text-align:center; font-variant-numeric: tabular-nums; }
    .toggle{ display:flex; gap:6px; align-items:center; }

    #trackerTip{
      position: fixed; z-index: 20;
      pointer-events: none;
      background: rgba(255,255,255,0.96);
      border: 1px solid rgba(0,0,0,0.25);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,.12);
      transform: translate(-50%, -120%);
      display: none;
      white-space: nowrap;
      will-change: left, top, transform;
    }
    #trackerTip .xy{ font-weight: 600; margin-right: 6px; }
    #trackerTip .meta{ opacity: .8; }

    .modal[hidden]{ display:none; }
    .modal{ position: fixed; inset: 0; z-index: 30; }
    .modal-backdrop{ position: absolute; inset: 0; background: rgba(0,0,0,.35); }
    .modal-card{
      position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%);
      width: min(420px, calc(100vw - 32px));
      background:#fff; border:1px solid #ccc; border-radius:12px; padding:16px;
      box-shadow: 0 12px 28px rgba(0,0,0,.24);
    }
    .modal-card h2{ margin:0 0 6px 0; font-size:18px; }
    .modal-card .hint{ margin:0 0 10px 0; opacity:.75; font-size: 12px; }
    .modal-card input{
      width:100%; padding:10px; font-size:16px; border:1px solid #bbb; border-radius:8px;
    }
    .modal-actions{ margin-top:12px; display:flex; gap:8px; justify-content:flex-end; }
    .modal-card .error{ color:#c00; margin-top:8px; min-height: 1.2em; }

    @media (max-width: 420px){
      #paletteBar{ grid-template-columns: 1fr; }
      .dockZoom{ flex-direction: row; }
    }
    @media (max-width: 480px){
      :root{ --gap: 6px; }
      body{ margin: 12px; }
      .dockZoom button{ width: 32px; height: 26px; font-size: 15px; }
    }
    #pseudoMenuModal .modal-card ul > li > button{
  width: 100%; padding: 10px 12px; border-radius: 8px; border: 1px solid #bbb; background: #fff; cursor: pointer;
}
#pseudoMenuModal .modal-card ul > li[style*="grid-template-columns"] > button{
  width: 42px; height: 36px; padding: 0; font-size: 20px; line-height: 1;
}
/* — Règles (modal) — */
.rules-overlay{
  position: fixed; inset: 0; background: rgba(0,0,0,.55);
  display: none; align-items: center; justify-content: center; z-index: 9999;
}
.rules-modal{
  width: min(560px, 92vw); background: #fff; color:#111; border-radius: 16px;
  box-shadow: 0 20px 60px rgba(0,0,0,.25); padding: 20px 20px 16px;
  border: 1px solid #ddd;
}
.rules-modal h2{ margin: 0 0 8px; font-size: 20px; }
.rules-modal p{ margin: 8px 0; line-height: 1.5; }
.rules-actions{ display:flex; justify-content:flex-end; gap: 8px; margin-top: 14px; }
.rules-ok{
  appearance: none; border: 0; border-radius: 12px; padding: 10px 16px; font-weight: 600;
  background:#111; color:#fff; cursor:not-allowed; opacity:.6;
}
.rules-ok.enabled{ cursor:pointer; opacity:1; }
.rules-count{ font-size: 12px; color:#666; margin-right:auto; align-self:center; }

  </style>
</head>
<body>
  <div class="titlebar">
    <h1>Le Grand Gribidouillage</h1>
    <button id="pseudoBtn" title="Options">Options</button>
  </div>

  <div class="ui" id="uiBar">
    <div>Prochain reset : <span id="countdown" class="dim">Pause</span></div>
    <div>Connectés : <span id="onlineCount" class="dim">0</span></div>
    <div>Pixels posés : <span id="clickCount" class="dim">0</span></div>
    <div>Coordonnées : <span id="coords" class="dim">—</span></div>
    <div class="zoomControls">
      <button id="zOut"  title="Zoom -">−</button>
      <div class="level" id="zLevel">100%</div>
      <button id="zIn"   title="Zoom +">+</button>
      <button id="zReset" title="Réinitialiser le zoom">Reset</button>
      <button id="trackerToggle" title="Activer/Désactiver le menu flottant Trackeur">Trackeur</button>
    </div>
    <label class="toggle" title="Afficher/masquer la grille">
      <input type="checkbox" id="showGridChk"> Grille
    </label>

  </div>

  <div id="viewport">
    <div id="space">
      <div id="sizer"></div>
      <div id="stageWrap">
        <canvas id="board"></canvas>
      </div>
    </div>
  </div>

  <aside id="paletteBar" aria-label="Palette de couleurs">
    <div id="paletteGrid" aria-label="Couleurs"></div>
    <div class="dockZoom">
      <button id="dockZIn"  title="Zoom +">+</button>
      <button id="dockZOut" title="Zoom -">−</button>
    </div>
  </aside>

  <div id="trackerTip" role="status" aria-live="polite">
    <span class="xy">(—, —)</span>
    <span class="meta"></span>
  </div>

  <div id="pseudoMenuModal" class="modal" hidden>
  <div class="modal-backdrop"></div>
  <div class="modal-card">
    <h2>Options</h2>
    <ul style="list-style:none; margin:10px 0 0 0; padding:0; display:flex; flex-direction:column; gap:10px;">
      <li>
        <button id="menuChangePseudo">Changer pseudo</button>
      </li>
      <li>
        <button id="menuDownloadPNG">Télécharger PNG</button>
      </li>
      <li style="display:grid; grid-template-columns:auto 1fr auto; align-items:center; gap:12px;">
        <button id="uiSizeMinus" title="Menu plus petit" aria-label="Réduire Menu">−</button>
        <span style="text-align:center; font-weight:600;">Menu</span>
        <button id="uiSizePlus" title="Menu plus grand" aria-label="Agrandir Menu">+</button>
      </li>
      <li style="display:grid; grid-template-columns:auto 1fr auto; align-items:center; gap:12px;">
        <button id="palSizeMinus" title="Palette plus petite" aria-label="Réduire Palette">−</button>
        <span style="text-align:center; font-weight:600;">Palette</span>
        <button id="palSizePlus" title="Palette plus grande" aria-label="Agrandir Palette">+</button>
      </li>
      <li>
        <button id="menuOpenAdmin">Admin</button>
      </li>
    </ul>
    <div class="modal-actions" style="justify-content:flex-end">
      <button id="menuClose">Fermer</button>
    </div>
  </div>
</div>

  <div id="pseudoModal" class="modal" hidden>
    <div class="modal-backdrop"></div>
    <div class="modal-card">
      <h2>Choisir un pseudo</h2>
      <p class="hint">3–20 caractères, lettres/chiffres/underscore. Unique.</p>
      <input id="pseudoInput" type="text" placeholder="MonPseudo" maxlength="20" />
      <div class="modal-actions">
        <button id="pseudoSave">Enregistrer</button>
        <button id="pseudoCancel">Annuler</button>
      </div>
      <p id="pseudoError" class="error" aria-live="polite"></p>
    </div>
  </div>

  <!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js" crossorigin="anonymous"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js" crossorigin="anonymous"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js" crossorigin="anonymous"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-storage-compat.js" crossorigin="anonymous"></script>

  <script>
    // ---- Diagnostics erreurs (affiche tout en console) ----
window.addEventListener('error', (e) => {
  console.error('[window.error]', {
    message: e.message, filename: e.filename, lineno: e.lineno, colno: e.colno,
    error: e.error && (e.error.stack || e.error)
  });
});
window.addEventListener('unhandledrejection', (e) => {
  console.error('[unhandledrejection]', e.reason && (e.reason.stack || e.reason));
});

    // === Bandeau erreurs JS (pour voir tout crash au chargement) ===
(function bootErrorBanner(){
  const bar = document.createElement('div');
  bar.style.cssText = "position:fixed;left:0;right:0;top:0;z-index:99999;display:none;background:#b00020;color:#fff;font:12px/1.3 system-ui, sans-serif;padding:6px 10px;white-space:pre-wrap";
  document.addEventListener('DOMContentLoaded', ()=> document.body.appendChild(bar));
  function show(msg){
    bar.textContent = "Erreur JS : " + msg;
    bar.style.display = 'block';
  }
  window.addEventListener('error', e => show(e.message || String(e)));
  window.addEventListener('unhandledrejection', e => show((e.reason && e.reason.message) || String(e.reason || e)));
})();
    
  // Import the functions you need from the SDKs you need
// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries
// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyCxWxz9Nf97tBwIilvCgqQ7yVk3gMPC4Cs",
  authDomain: "le-grand-gribidouillage.firebaseapp.com",
  projectId: "le-grand-gribidouillage",
  storageBucket: "le-grand-gribidouillage.firebasestorage.app",
  messagingSenderId: "999048366927",
  appId: "1:999048366927:web:1120aca9e541873a93d33a"
  databaseURL: "https://le-grand-gribidouillage-default-rtdb.europe-west1.firebasedatabase.app"
};
// Initialize Firebase
firebase.initializeApp(firebaseConfig);
const db = firebase.database();
    

// --- [NOUVEAU] Watchers Firebase propres (compat API) ---
const _fbListeners = new Map(); // path -> { ref, cb }
function watchValue(path, handler) {
  if (_fbListeners.has(path)) return _fbListeners.get(path).off; // déjà attaché
  const ref = firebase.database().ref(path);
  const cb = snap => handler(snap);
  ref.on('value', cb);
  const off = () => { try { ref.off('value', cb); } catch(e){} _fbListeners.delete(path); };
  _fbListeners.set(path, { ref, cb, off });
  return off;
}
function offAllWatchers(){
  for (const {ref, cb} of _fbListeners.values()) {
    try { ref.off('value', cb); } catch(e){}
  }
  _fbListeners.clear();
}

// --- [NOUVEAU] Garde anti-feedback (empêche les boucles écriture<->lecture) ---
let _isApplyingRemote = false;

function safeSet(ref, data) {
  if (_isApplyingRemote) return;   // ignore les writes pendant l’application UI
  return ref.set(data);
}
function safeUpdate(ref, data) {
  if (_isApplyingRemote) return;
  return ref.update(data);
}

// (ton code existant continue ici…)

  const auth = firebase.auth();
  const db   = firebase.database();
let storage = null;
try {
  storage = firebase.storage();
} catch (e) {
  console.warn('Firebase Storage non initialisé :', e);
}

  // === Paramètres mosaïque ===
  const IS_MOBILE = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
  const W = 300, H = 300;
  let PIX = IS_MOBILE ? 8 : 10;
  const canvas = document.getElementById('board');
  canvas.width  = W * PIX;
  canvas.height = H * PIX;
  const ctx = canvas.getContext('2d');
// Rect du canvas mis à jour intelligemment (évite les mesures à chaque mousemove)
let _canvasRect = null;
function measureCanvasRect(){
  // Mesure “fraîche” après un frame de rendu
  _canvasRect = canvas.getBoundingClientRect();
}
  // === Palette ===
 const colors = [
  // Neutres (indices invariants utiles : 0 = Noir, 1 = Blanc*)
  '#000000', // 0 Noir
  '#FFFFFF', // 1 Blanc* (stockage/rendu) → affiché comme "Gomme" dans l'UI

  '#2F2F2F', // 2 Gris anthracite
  '#808080', // 3 Gris moyen
  '#D3D3D3', // 4 Gris clair

  // Rouges
  '#B22222', // 5 Carmin
  '#FF0000', // 6 Rouge vif
  '#FFC0CB', // 7 Rose clair

  // Oranges
  '#8B4513', // 8 Brun chaud
  '#FF7F00', // 9 Orange vif
  '#FFDAB9', // 10 Pêche

  // Jaunes
  '#FFD700', // 11 Or profond
  '#FFFF00', // 12 Jaune soleil
  '#FFFACD', // 13 Jaune pastel

  // Verts
  '#006400', // 14 Vert forêt
  '#00FF00', // 15 Vert herbe
  '#ADFF2F', // 16 Vert anis

  // Turquoises
  '#008080', // 17 Sarcelle
  '#40E0D0', // 18 Turquoise
  '#00FFFF', // 19 Aqua

  // Bleus
  '#000080', // 20 Bleu marine
  '#0000FF', // 21 Bleu roi
  '#87CEEB', // 22 Bleu ciel

  // Violets (renforcés)
  '#4B0082', // 23 Violet profond
  '#8A2BE2', // 24 Violet pur
  '#BA55D3', // 25 Violet clair
  '#E0B0FF', // 26 Lilas clair

  // Couleur de clôture pour spectre maxi coloré
  '#FF00FF', // 27 Fuchsia (magenta vif)
];

    // Ordre visuel de rendu des swatches (indices du tableau colors)
const PALETTE_ORDER = [
  0, 2, 3, 4, 1,      // Noir → Gris anth → Gris moyen → Gris clair → (1=Blanc→Gomme UI)
  5, 6, 7,            // Rouges
  8, 9, 10,           // Oranges
  11,12,13,           // Jaunes
  14,15,16,           // Verts
  17,18,19,           // Turquoises
  20,21,22,           // Bleus
  23,24,25,26,        // Violets renforcés
  27                  // Fuchsia
];

  let selected = 0;
// ——— Sélection gomme ———
let selectedIsEraser = false; // true = outil Gomme actif

  // === Références DOM ===
  const viewport   = document.getElementById('viewport');
  const sizer      = document.getElementById('sizer');
  const stageWrap  = document.getElementById('stageWrap');
  const paletteGrid= document.getElementById('paletteGrid');
  const paletteBar = document.getElementById('paletteBar');
  const uiBar      = document.getElementById('uiBar');
  const countdownEl= document.getElementById('countdown');
  const onlineEl   = document.getElementById('onlineCount');
  const clickEl    = document.getElementById('clickCount');
  const coordsEl   = document.getElementById('coords');
  const zLevelEl   = document.getElementById('zLevel');
  const showGridChk= document.getElementById('showGridChk');
  const trackerToggle = document.getElementById('trackerToggle');
  const trackerTip = document.getElementById('trackerTip');
  const palSizeMinus = document.getElementById('palSizeMinus');
  const palSizePlus  = document.getElementById('palSizePlus');
  const uiSizeMinus  = document.getElementById('uiSizeMinus');
  const uiSizePlus   = document.getElementById('uiSizePlus');

  const trackerXY  = trackerTip.querySelector('.xy');
  const trackerMeta= trackerTip.querySelector('.meta');
  const SCALE_STEPS = [0.75, 1, 1.25];
  function clampIndex(i){ return Math.max(0, Math.min(SCALE_STEPS.length-1, i)); }


  // === Trackeur (état mémorisé) ===
  let trackerOn = (localStorage.getItem('pw-tracker') ?? '1') === '1';
  function updateTrackerToggleUI(){
    trackerToggle.classList.toggle('active', trackerOn);
    trackerToggle.style.background = trackerOn ? '#000' : '';
    trackerToggle.style.color = trackerOn ? '#fff' : '';
  }
  trackerToggle.addEventListener('click', ()=>{
    trackerOn = !trackerOn;
    localStorage.setItem('pw-tracker', trackerOn ? '1' : '0');
    updateTrackerToggleUI();
    if (!trackerOn) trackerTip.style.display = 'none';
  });
  updateTrackerToggleUI();

      // --- État persistant des tailles
  let palScaleIdx = clampIndex(parseInt(localStorage.getItem('pw-pal-scale-idx') || '1', 10)); // défaut 100%
  let uiScaleIdx  = clampIndex(parseInt(localStorage.getItem('pw-ui-scale-idx')  || '1', 10)); // défaut 100%

  function applyPalScale(){
    const f = SCALE_STEPS[palScaleIdx];
    document.documentElement.style.setProperty('--pal-scale', String(f));
    // Le layout dépend des tailles → re-layout
    scheduleRelayout();
  }
  function applyUiScale(){
    const f = SCALE_STEPS[uiScaleIdx];
    document.documentElement.style.setProperty('--ui-scale', String(f));
    scheduleRelayout();
  }
  applyPalScale();
  applyUiScale();

  // === Layout : viewport borné entre le header et la palette ===
let _vp_lastTop = '';   // ← ajoute ces 2 lignes quelque part au-dessus (scope global)
let _vp_lastBottom = '';

function layoutViewport(){
  const uiBottom = uiBar.getBoundingClientRect().bottom;
  const palTop   = paletteBar.getBoundingClientRect().top;

  const rootCS  = getComputedStyle(document.documentElement);
  const safeBtm = parseFloat(rootCS.getPropertyValue('--safe-bottom')) || 0;

  const newTop = Math.round(uiBottom + 8) + 'px';

  let bottomSpace = Math.round(Math.max(0, window.innerHeight - palTop) + 8 + safeBtm);
  if (!Number.isFinite(bottomSpace) || bottomSpace <= 0){
    const barHVar = parseFloat(rootCS.getPropertyValue('--bar-h')) || 92;
    bottomSpace = Math.round(barHVar + 8 + safeBtm);
  }
  const newBottom = bottomSpace + 'px';

  if (newTop !== _vp_lastTop){ viewport.style.top = newTop; _vp_lastTop = newTop; }
  if (newBottom !== _vp_lastBottom){ viewport.style.bottom = newBottom; _vp_lastBottom = newBottom; }
}

  // === Grilles mémoire ===
  let grid = Array.from({length:H}, ()=>Array.from({length:W}, ()=>1));
  const authorGrid = Array.from({length:H}, ()=>Array.from({length:W}, ()=>null));
  const tsGrid     = Array.from({length:H}, ()=>Array.from({length:W}, ()=>null));

  function drawCell(x,y){ ctx.fillStyle = colors[grid[y][x]]; ctx.fillRect(x*PIX, y*PIX, PIX, PIX); }
  function fullPixels(){ for (let y=0;y<H;y++) for (let x=0;x<W;x++) drawCell(x,y); }
// Cache/calque de la grille (offscreen)
let gridOverlayCache = null;
function makeGridOverlay(){
  const oc = document.createElement('canvas');
  oc.width = canvas.width;    // = W*PIX
  oc.height = canvas.height;  // = H*PIX
  const octx = oc.getContext('2d');
  const thin = 'rgba(0,0,0,0.15)', bold = 'rgba(0,0,0,0.35)';

  octx.save(); octx.lineWidth = 1;

  // Colonnes
  octx.beginPath(); octx.strokeStyle = thin;
  for (let x=0; x<=W; x++){
    const xx = x*PIX + 0.5;
    if (x % 10 === 0){
      octx.stroke(); octx.beginPath(); octx.strokeStyle = bold;
      octx.moveTo(xx, 0); octx.lineTo(xx, H*PIX); octx.stroke();
      octx.beginPath(); octx.strokeStyle = thin;
    } else {
      octx.moveTo(xx, 0); octx.lineTo(xx, H*PIX);
    }
  }
  octx.stroke();

  // Lignes
  octx.beginPath(); octx.strokeStyle = thin;
  for (let y=0; y<=H; y++){
    const yy = y*PIX + 0.5;
    if (y % 10 === 0){
      octx.stroke(); octx.beginPath(); octx.strokeStyle = bold;
      octx.moveTo(0, yy); octx.lineTo(W*PIX, yy); octx.stroke();
      octx.beginPath(); octx.strokeStyle = thin;
    } else {
      octx.moveTo(0, yy); octx.lineTo(W*PIX, yy);
    }
  }
  octx.stroke();
  octx.restore();

  return oc;
}

function drawGridOverlay(){
  if (!gridOverlayCache) gridOverlayCache = makeGridOverlay();
  ctx.drawImage(gridOverlayCache, 0, 0);
}
  fullPixels();
  if (localStorage.getItem('pw-show-grid') === '1') { showGridChk.checked = true; drawGridOverlay(); }
  else { showGridChk.checked = false; }
  showGridChk.addEventListener('change', ()=>{
    localStorage.setItem('pw-show-grid', showGridChk.checked ? '1' : '0');
    fullPixels(); if (showGridChk.checked) drawGridOverlay();
  });

  function makeColorCursor(hex, size = 22) {
    const r = Math.floor(size/2) - 2;
    const svg =
      `<svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}'>` +
        `<circle cx='${size/2}' cy='${size/2}' r='${r}' fill='${hex}'/>` +
        `<circle cx='${size/2}' cy='${size/2}' r='${r-0.5}' fill='none' stroke='white' stroke-width='2'/>` +
        `<circle cx='${size/2}' cy='${size/2}' r='${r-2.5}' fill='none' stroke='black' stroke-width='1.5'/>` +
      `</svg>`;
    return `url("data:image/svg+xml;utf8,${encodeURIComponent(svg)}") ${Math.floor(size/2)} ${Math.floor(size/2)}, crosshair`;
  }
    
    function makeEraserCursor(size = 22){
  const r = Math.floor(size/2) - 2;
  const svg =
    `<svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}'>` +
      `<defs><pattern id='chk' width='6' height='6' patternUnits='userSpaceOnUse'>` +
        `<rect width='6' height='6' fill='#fff'/><path d='M0,0 L6,6 M-3,3 L3,9 M3,-3 L9,3' stroke='#ddd'/>` +
      `</pattern></defs>` +
      `<circle cx='${size/2}' cy='${size/2}' r='${r}' fill='url(#chk)' stroke='#999' stroke-width='2'/>` +
      `<line x1='4' y1='4' x2='${size-4}' y2='${size-4}' stroke='#b00' stroke-width='2'/>` +
    `</svg>`;
  return `url("data:image/svg+xml;utf8,${encodeURIComponent(svg)}") ${Math.floor(size/2)} ${Math.floor(size/2)}, crosshair`;
}

    function updateCursor(){
  if (selectedIsEraser) canvas.style.cursor = makeEraserCursor();
  else canvas.style.cursor = makeColorCursor(colors[selected]);
}

  canvas.addEventListener('mouseenter', updateCursor);
  canvas.addEventListener('mouseleave', ()=>{ canvas.style.cursor = 'default'; coordsEl.textContent = '—'; trackerTip.style.display='none'; });

function buildPalette(){
  paletteGrid.innerHTML = '';
  PALETTE_ORDER.forEach((idx)=>{
    const sw = document.createElement('div');
    sw.className = 'sw';

    if (idx === 1) {
      // ——— Gomme (remplace le blanc dans l’UI)
      sw.title = 'Gomme — effacer le pixel';
      sw.style.background = '#FFFFFF'; // visuel blanc pur
      // bordure fine comme les autres, pas de damier (convenu)
      if (selectedIsEraser) sw.classList.add('activeSw');
      sw.onclick = ()=>{
        selected = 1;
        selectedIsEraser = true;
        [...paletteGrid.children].forEach(el => el.classList.remove('activeSw'));
        sw.classList.add('activeSw');
        updateCursor();
      };
    } else {
      const hex = colors[idx];
      sw.style.background = hex;
      sw.title = hex;
      if (!selectedIsEraser && idx === selected) sw.classList.add('activeSw');
      sw.onclick = ()=>{
        selected = idx;
        selectedIsEraser = (idx === 1);
        [...paletteGrid.children].forEach(el => el.classList.remove('activeSw'));
        sw.classList.add('activeSw');
        updateCursor();
      };
    }

    paletteGrid.appendChild(sw);
  });
}

 // Cache de dernière mise en page pour court-circuiter les no-op
let _pal_lastW = -1, _pal_lastCols = -1, _pal_lastSW = -1, _pal_lastBarH = -1;

function layoutPaletteTwoRows(){
  const total = colors.length;
  const cols = Math.ceil(total / 2);

  const bar  = paletteBar;
  const btns = bar.querySelector('.dockZoom');

  // Mesures légères (évite getBoundingClientRect pour la largeur globale)
  // clientWidth = contenu + padding (sans bordure), ça suffit ici.
  const barW  = bar.clientWidth;
  const btnW  = btns ? btns.offsetWidth : 0;

  // Court-circuit si la largeur n'a quasi pas bougé ET mêmes colonnes
  // (±1px = bruit ; évite les re-écritures)
  if (Math.abs(barW - _pal_lastW) < 1 && cols === _pal_lastCols) return;

  // Une seule lecture de styles calculés par élément
  const rootCS = getComputedStyle(document.documentElement);
  const barCS  = getComputedStyle(bar);

  const padX = parseFloat(barCS.paddingLeft) + parseFloat(barCS.paddingRight);
  const padY = parseFloat(barCS.paddingTop)  + parseFloat(barCS.paddingBottom);

  const gap = parseFloat(rootCS.getPropertyValue('--gap')) || 8;

  // Largeur dispo pour la grille (évite la magie du 10 : garde un petit espace)
  const available = Math.max(120, barW - btnW - 10 - padX);

  // Taille de swatch
  const sw = Math.floor((available - gap * (cols - 1)) / cols);
  const minSw = 18, maxSw = IS_MOBILE ? 28 : 32;
  const clamped = Math.max(minSw, Math.min(maxSw, sw));

  // Hauteur totale du bandeau (2 lignes + 1 gap + padding vertical)
  const barH = Math.ceil((clamped * 2) + gap + padY);

  // Écritures conditionnelles (évite les styles identiques → pas d’invalidation)
  if (cols !== _pal_lastCols) {
    bar.style.setProperty('--cols', String(cols));
    _pal_lastCols = cols;
  }
  if (clamped !== _pal_lastSW) {
    bar.style.setProperty('--sw', clamped + 'px');
    _pal_lastSW = clamped;
  }
  if (barH !== _pal_lastBarH) {
    document.documentElement.style.setProperty('--bar-h', barH + 'px');
    _pal_lastBarH = barH;
  }

  // Mémoriser la largeur
  _pal_lastW = barW;
}


let _sizer_w = -1, _sizer_h = -1;
function updateSizer(){
  const scaledW = Math.ceil(W * PIX * zoom);
  const scaledH = Math.ceil(H * PIX * zoom);
  if (scaledW !== _sizer_w) { sizer.style.width  = scaledW + 'px'; _sizer_w = scaledW; }
  if (scaledH !== _sizer_h) { sizer.style.height = scaledH + 'px'; _sizer_h = scaledH; }
}

  function clampScroll(){
    const maxLeft = Math.max(0, sizer.offsetWidth  - viewport.clientWidth );
    const maxTop  = Math.max(0, sizer.offsetHeight - viewport.clientHeight);
    if (viewport.scrollLeft < 0) viewport.scrollLeft = 0;
    else if (viewport.scrollLeft > maxLeft) viewport.scrollLeft = maxLeft;
    if (viewport.scrollTop < 0) viewport.scrollTop = 0;
    else if (viewport.scrollTop > maxTop) viewport.scrollTop = maxTop;
  }
   // ---- Scheduler de relayout (regroupe tout dans une seule rAF) ----
var layoutScheduled = false;
var isLayingOut = false; 
var _ro = null; // ref du ResizeObserver pour (dé)brancher pendant le layout
  
    function scheduleRelayout(){
  if (layoutScheduled) return;
  layoutScheduled = true;
  requestAnimationFrame(()=>{
    layoutScheduled = false;
    isLayingOut = true; // ← on pose le verrou
    try {
      layoutPaletteTwoRows();
      layoutViewport();
      updateSizer();
      clampScroll();
      measureCanvasRect();
    } catch (e) {
      console.error('[scheduleRelayout] crash:', e);
    } finally {
      isLayingOut = false; // ← toujours relâché, même en cas d’erreur
    }
  });
}


  let zoom = 1;
  const ZOOM_MIN = 0.25, ZOOM_MAX = 4, ZOOM_STEP = 1.12;
  function clampZoom(z){ return Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, z)); }
  function applyZoom(){
    stageWrap.style.transform = `scale(${zoom})`;
    zLevelEl.textContent = `${Math.round(zoom*100)}%`;
    updateSizer();
  requestAnimationFrame(measureCanvasRect);
  }
  function setZoomCentered(newZoom){
    const vp = viewport;
    const logicalCX = (vp.scrollLeft + vp.clientWidth/2) / zoom;
    const logicalCY = (vp.scrollTop  + vp.clientHeight/2) / zoom;
    zoom = clampZoom(newZoom);
    applyZoom();
    vp.scrollLeft = logicalCX * zoom - vp.clientWidth/2;
    vp.scrollTop  = logicalCY * zoom - vp.clientHeight/2;
    clampScroll();
  }
    // --- Zoom autour d'un point (coordonnées en pixels "client" dans le viewport) ---
function setZoomAroundPoint(newZoom, pxClient, pyClient){
  const vp = viewport;
  const rect = vp.getBoundingClientRect();

  // Coordonnées logiques du point visé avant le changement de zoom
  const logicalX = (vp.scrollLeft + (pxClient - rect.left)) / zoom;
  const logicalY = (vp.scrollTop  + (pyClient - rect.top )) / zoom;

  zoom = clampZoom(newZoom);
  applyZoom();

  // Recalage du scroll pour que le point visé reste au même endroit à l’écran
  vp.scrollLeft = logicalX * zoom - (pxClient - rect.left);
  vp.scrollTop  = logicalY * zoom - (pyClient - rect.top);

  clampScroll();
}

 function zoomIn(){
  const rect = viewport.getBoundingClientRect();
  const cx = rect.left + rect.width / 2;
  const cy = rect.top  + rect.height / 2;
  setZoomAroundPoint(clampZoom(zoom * ZOOM_STEP), cx, cy);
}
function zoomOut(){
  const rect = viewport.getBoundingClientRect();
  const cx = rect.left + rect.width / 2;
  const cy = rect.top  + rect.height / 2;
  setZoomAroundPoint(clampZoom(zoom / ZOOM_STEP), cx, cy);
}

  document.getElementById('zIn').onclick = zoomIn;
  document.getElementById('zOut').onclick = zoomOut;
  document.getElementById('zReset').onclick = ()=>{ zoom = 1; applyZoom(); clampScroll(); };
  document.getElementById('dockZIn').onclick  = zoomIn;
  document.getElementById('dockZOut').onclick = zoomOut;

  const activePointers = new Map();
  let pinchStartDist = 0, pinchStartZoom = 1, pinchInProgress = false;
  function pointersDistance(){
    const arr = [...activePointers.values()];
    if (arr.length < 2) return 0;
    const dx = arr[0].x - arr[1].x, dy = arr[0].y - arr[1].y;
    return Math.hypot(dx, dy);
  }
  function setTouchActionDuringPinch(on){ viewport.style.touchAction = on ? 'none' : 'pan-x pan-y'; }
  viewport.addEventListener('pointerdown', (e)=>{
    activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
    if (activePointers.size === 2){
      pinchInProgress = true; pinchStartDist = pointersDistance(); pinchStartZoom = zoom;
      setTouchActionDuringPinch(true); e.preventDefault();
    }
  }, { passive:false 
  });
    
 viewport.addEventListener('pointermove', (e)=>{
  if (!activePointers.has(e.pointerId)) return;

  // Mettre à jour la position du pointeur courant
  activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

  if (pinchInProgress && activePointers.size >= 2){
    const dist = pointersDistance();
    if (dist > 0 && pinchStartDist > 0){
      // 1) Filtre anti-jitter : ignorer < ~2% de variation
      const rawFactor = dist / pinchStartDist;
      if (Math.abs(rawFactor - 1) < 0.02) { e.preventDefault(); return; }

      // 2) Courbe douce pour un feeling naturel
      const eased = Math.pow(rawFactor, 0.85);
      const newZoom = clampZoom(pinchStartZoom * eased);

      // 3) Centroïde des deux doigts (point autour duquel on zoome)
      const arr = [...activePointers.values()];
      const cx = (arr[0].x + arr[1].x) / 2;
      const cy = (arr[0].y + arr[1].y) / 2;

      // 4) Zoom en gardant le centroïde fixe à l’écran
      setZoomAroundPoint(newZoom, cx, cy);

      e.preventDefault(); // bloque le scroll pendant le pinch
    }
  }
}, { passive:false });

  function endPointer(e){
    if (activePointers.has(e.pointerId)) activePointers.delete(e.pointerId);
    if (activePointers.size < 2 && pinchInProgress){
      pinchInProgress = false; setTouchActionDuringPinch(false); clampScroll();
    }
  }
  viewport.addEventListener('pointerup', endPointer, { passive:true });
  viewport.addEventListener('pointercancel', endPointer, { passive:true });
  viewport.addEventListener('pointerleave', endPointer, { passive:true });

  function screenToGrid(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const localX = (clientX - rect.left) / zoom;
    const localY = (clientY - rect.top)  / zoom;
    const x = Math.floor(localX / PIX), y = Math.floor(localY / PIX);
    return { x, y };
  }
  function timeAgoFR(ts){
    if (!ts) return '';
    const s = Math.max(1, Math.floor((Date.now() - ts)/1000));
    if (s < 60) return `il y a ${s}s`;
    const m = Math.floor(s/60); if (m < 60) return `il y a ${m} min`;
    const h = Math.floor(m/60); if (h < 24) return `il y a ${h} h`;
    const d = Math.floor(h/24); return `il y a ${d} j`;
  }
  function uidShort(uid){ return uid ? String(uid).slice(0,6) : '—'; }

  const namesByUid = {};
  let myName = null;

  const pseudoBtn    = document.getElementById('pseudoBtn');

  const pseudoMenuModal = document.getElementById('pseudoMenuModal');
  const menuChangePseudo = document.getElementById('menuChangePseudo');
  const menuOpenAdmin = document.getElementById('menuOpenAdmin');
  const menuClose = document.getElementById('menuClose');

  const pseudoModal  = document.getElementById('pseudoModal');
  const pseudoInput  = document.getElementById('pseudoInput');
  const pseudoSave   = document.getElementById('pseudoSave');
  const pseudoCancel = document.getElementById('pseudoCancel');
  const pseudoError  = document.getElementById('pseudoError');

  function updatePseudoBtn() { pseudoBtn.textContent = 'Options'; }
    
  function openPseudoMenu(){ pseudoMenuModal.hidden = false; }
  function closePseudoMenu(){ pseudoMenuModal.hidden = true; }
  menuChangePseudo.addEventListener('click', ()=>{ closePseudoMenu(); openPseudoModal(); });
  menuOpenAdmin.addEventListener('click', ()=>{ window.open('admin.html', '_blank'); });
  menuClose.addEventListener('click', closePseudoMenu);
  pseudoMenuModal.querySelector('.modal-backdrop').addEventListener('click', closePseudoMenu);

  function openPseudoModal(){
    pseudoError.textContent = '';
    pseudoInput.value = myName || '';
    if (!myName) { pseudoCancel.style.display = 'none'; } else { pseudoCancel.style.display = ''; }
    pseudoModal.hidden = false;
    setTimeout(()=> pseudoInput.focus(), 0);
  }
  function closePseudoModal(){ pseudoModal.hidden = true; }

  pseudoBtn.addEventListener('click', openPseudoMenu);
  pseudoCancel.addEventListener('click', ()=>{ if (myName) closePseudoModal(); });
  pseudoModal.querySelector('.modal-backdrop').addEventListener('click', ()=>{ if (myName) closePseudoModal(); });
  pseudoInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') savePseudo(); });
  document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape' && !myName && !pseudoModal.hidden){ e.preventDefault(); e.stopPropagation(); } }, true);

  function normalizeName(s){ return s.trim(); }
  function toKey(s){ return s.toLowerCase().replace(/[^a-z0-9_]/g,''); }
  function isValidName(s){ return /^[A-Za-z0-9_]{3,20}$/.test(s); }

  // Cache des requêtes en cours pour ne jamais lancer 2x la même
const _pendingNames = new Set();

function ensureName(uid){
  if (!uid) return;
  if (namesByUid[uid]) return;          // déjà connu
  if (_pendingNames.has(uid)) return;   // requête déjà en vol
  _pendingNames.add(uid);
  db.ref(`users/${uid}/name`).once('value').then(s=>{
    const n = s.val();
    if (n && typeof n === 'string') namesByUid[uid] = n;
  }).catch(()=>{}).finally(()=>{
    _pendingNames.delete(uid);
  });
}


  async function savePseudo(){
    try {
      const raw = normalizeName(pseudoInput.value);
      if (!isValidName(raw)){ pseudoError.textContent = "Pseudo invalide (3–20 caractères, lettres/chiffres/_)."; return; }
      const key = toKey(raw);
      if (!key){ pseudoError.textContent = "Pseudo invalide."; return; }
      if (!CURRENT_UID){ pseudoError.textContent = "Authentification en cours… réessaie."; return; }

      const prevSnap = await db.ref(`users/${CURRENT_UID}/name`).once('value');
      const prevName = prevSnap.val();
      const prevKey  = prevName ? toKey(prevName) : null;
      if (prevName && prevName === raw){ pseudoError.textContent = ""; closePseudoModal(); return; }

      const refClaim = db.ref(`users_by_name/${key}`);
      const tx = await refClaim.transaction(cur => {
        if (cur === null || cur === CURRENT_UID) { return CURRENT_UID; }
        return;
      });
      if (!tx.committed || tx.snapshot.val() !== CURRENT_UID){
        pseudoError.textContent = "Ce pseudo est déjà pris.";
        return;
      }

      {
  const nameRef = db.ref(`users/${CURRENT_UID}/name`);
  await safeSet(nameRef, raw);
}

if (prevKey && prevKey !== key){
  const refOld = db.ref(`users_by_name/${prevKey}`);
  await refOld.transaction(cur => (cur === CURRENT_UID ? null : cur));
}


      myName = raw;
      namesByUid[CURRENT_UID] = raw;
      updatePseudoBtn();
      closePseudoModal();
      // Mémoriser et prévenir la pop-up Règles
localStorage.setItem('nickname', myName);
document.dispatchEvent(new CustomEvent('pseudo:chosen'));

    } catch (err){
      console.error(err);
      pseudoError.textContent = "Erreur réseau. Réessaie.";
    }
  }
  pseudoSave.addEventListener('click', savePseudo);

  function updateTracker(e){
    if (!trackerOn) return;
    const {x,y} = screenToGrid(e.clientX, e.clientY);
    if (x>=0 && x<W && y>=0 && y<H){
      trackerXY.textContent = `(${x}, ${y})`;
      const uid = authorGrid[y][x];
      const display = uid ? (namesByUid[uid] || uidShort(uid)) : '—';
      const when = tsGrid[y][x];
      const ago = when ? `, ${timeAgoFR(when)}` : '';
      trackerMeta.textContent = `${display}${ago}`;
      trackerTip.style.display = 'block';
      const offsetX = 14, offsetY = 18;
      let tx = e.clientX + offsetX, ty = e.clientY - offsetY;
      const rect = trackerTip.getBoundingClientRect();
      if (tx + rect.width > window.innerWidth - 6) tx = window.innerWidth - rect.width - 6;
      if (ty - rect.height < 6) ty = e.clientY + offsetY;
      trackerTip.style.left = tx + 'px';
      trackerTip.style.top  = ty + 'px';
    } else {
      trackerTip.style.display = 'none';
    }
  }

 // --- Tracker & coords : coalescé à la frame ---
let _mmQueued = false;
let _mmClientX = 0, _mmClientY = 0;
let _tipW = 0, _tipH = 0; // cache dimensions du tip

let _lastHoverX = -9999, _lastHoverY = -9999;

function rafHoverUpdate(){
  _mmQueued = false;

  // 0) Garde anti-jitter
  if (_mmClientX === _lastHoverX && _mmClientY === _lastHoverY) return;
  _lastHoverX = _mmClientX; _lastHoverY = _mmClientY;

  // 1) Convertir en coords grille avec rect “frais”
  const rect = _canvasRect || canvas.getBoundingClientRect(); // fallback au 1er tour

  const localX = (_mmClientX - rect.left) / zoom;
  const localY = (_mmClientY - rect.top)  / zoom;
  const x = Math.floor(localX / PIX), y = Math.floor(localY / PIX);

  // 2) Coords HUD
  if (x>=0 && x<W && y>=0 && y<H){
    coordsEl.textContent = `(${x}, ${y})`;
  } else {
    coordsEl.textContent = '—';
  }

  // 3) Tracker tip (si activé)
  if (!trackerOn) { trackerTip.style.display = 'none'; return; }

  if (x>=0 && x<W && y>=0 && y<H){
    const uid = authorGrid[y][x];
    const display = uid ? (namesByUid[uid] || uidShort(uid)) : '—';
    const when = tsGrid[y][x];
    const ago = when ? `, ${timeAgoFR(when)}` : '';

    trackerXY.textContent = `(${x}, ${y})`;
    trackerMeta.textContent = `${display}${ago}`;

    // Afficher si caché et mesurer 1x
    if (trackerTip.style.display !== 'block'){
      trackerTip.style.display = 'block';
      // première mesure (1x) – coût négligeable car coalescé
      const r = trackerTip.getBoundingClientRect();
      _tipW = r.width; _tipH = r.height;
    }

    // 4) Positionner sans dépasser l'écran (utilise le cache largeur/hauteur)
    const offsetX = 14, offsetY = 18;
    let tx = _mmClientX + offsetX;
    let ty = _mmClientY - offsetY;

    if (tx + _tipW > window.innerWidth - 6) tx = window.innerWidth - _tipW - 6;
    if (ty - _tipH < 6) ty = _mmClientY + offsetY;

    trackerTip.style.left = tx + 'px';
    trackerTip.style.top  = ty + 'px';
  } else {
    trackerTip.style.display = 'none';
  }
}

// Souris
canvas.addEventListener('mousemove', (e)=>{
  _mmClientX = e.clientX; _mmClientY = e.clientY;
  if (!_mmQueued){ _mmQueued = true; requestAnimationFrame(rafHoverUpdate); }
  }, { passive: true 
});

// Tactile (doigt) sur le canvas
canvas.addEventListener('pointermove', (e)=>{
  if (e.pointerType !== 'touch') return;
  _mmClientX = e.clientX; _mmClientY = e.clientY;
  if (!_mmQueued){ _mmQueued = true; requestAnimationFrame(rafHoverUpdate); }
}, { passive:true });

canvas.addEventListener('pointerleave', ()=>{
  trackerTip.style.display = 'none';
  coordsEl.textContent = '—';
  }, { passive: true
});


  function formatParisFilename(prefix="snapshot", ext="png"){
    const fmt = new Intl.DateTimeFormat('fr-FR',{ timeZone:'Europe/Paris', year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit' });
    const parts = fmt.formatToParts(new Date());
    const get=t=>parts.find(p=>p.type===t)?.value||'';
    const stamp = `${get('year')}-${get('month')}-${get('day')}_${get('hour')}-${get('minute')}-${get('second')}`;
    return `${prefix}_${stamp}.${ext}`;
  }
  function canvasToBlobPNG(cnv){ return new Promise(res => cnv.toBlob(b => res(b), 'image/png')); }
async function uploadSnapshot(folder, filename){
  if (!storage) {
    console.warn('Upload ignoré : Storage indisponible');
    return { path: null, url: null };
  }    await new Promise(r => requestAnimationFrame(r));
    const blob = await canvasToBlobPNG(canvas);
    const path = `${folder}/${filename}`;
    const ref = storage.ref().child(path);
    await ref.put(blob, { contentType: 'image/png' });
    const url = await ref.getDownloadURL();
    console.log('Snapshot uploadé →', path, url);
    return { path, url };
  }

  const PERIOD_RESET=48*60*60*1000, PERIOD_ARCHIVE=60*1000;
  const nextResetRef=db.ref('config/nextResetAt'), lastResetRef=db.ref('config/lastResetAt');
  const nextArchRef=db.ref('config/nextArchiveAt'), lastArchRef=db.ref('config/lastArchiveAt');
function updateCountdown(ts){
  countdownEl.innerHTML = '<span style="color:#b00020;font-weight:700">Ce soir&nbsp;Minuit</span>';
}
  async function tryReset(){ return; }
  async function tryArchive(){
    const now=Date.now(); let commit=false, newNext=null;
    const res = await nextArchRef.transaction(cur => {
      if (cur===null){ newNext=now+PERIOD_ARCHIVE; commit=true; return newNext; }
      if (now>=cur){ newNext=now+PERIOD_ARCHIVE; commit=true; return newNext; }
      return;
    });
    if (res.committed && commit) {
      try {
        await uploadSnapshot('archive', formatParisFilename('archive','png'));
        await lastArchRef.set(now);
      } catch(e) { console.warn('Archive échouée:', e); }
    }
  }

  const infoConnectedRef = db.ref('.info/connected');
  const presenceRootRef  = db.ref('presence');
  const clicksRef        = db.ref('stats/clicksTotal');
// Buffer local pour les clics (évite les transactions à chaque pose)
let _clicksBuffer = 0;
let _clicksFlushTimer = null;

function flushClicks(){
  if (_clicksBuffer <= 0) return;
  const n = _clicksBuffer;
  _clicksBuffer = 0;
  // Incrément atomique côté RTDB (compatible compat SDK)
  clicksRef.set(firebase.database.ServerValue.increment(n)).catch(()=>{
    // En cas d’erreur réseau, on remet dans le buffer
    _clicksBuffer += n;
  });
}

function scheduleClicksFlush(){
  if (_clicksFlushTimer) return;
  _clicksFlushTimer = setTimeout(()=>{
    _clicksFlushTimer = null;
    flushClicks();
  }, 1500); // flush 1,5s après la dernière pose
}

// Flush quand on quitte/masque l’onglet
document.addEventListener('visibilitychange', ()=>{
  if (document.visibilityState === 'hidden') flushClicks();
});
window.addEventListener('pagehide', flushClicks);

  let CURRENT_UID = null;

  auth.signInAnonymously().catch(console.error);
  auth.onAuthStateChanged(user => {
    if (!user) return;
    CURRENT_UID = user.uid;

  watchValue(`users/${CURRENT_UID}/name`, (s)=>{
  _isApplyingRemote = true;
  try {
    const n = s.val();
    myName = (typeof n === 'string' && n) ? n : null;
    if (myName) {
      namesByUid[CURRENT_UID] = myName;
      localStorage.setItem('nickname', myName); // ← NEW : garde en local
    } else {
      localStorage.removeItem('nickname');      // ← NEW : nettoyage si aucun pseudo
    }
    updatePseudoBtn();
    if (!myName) openPseudoModal();
  } finally {
    _isApplyingRemote = false;
  }
});



 const myPresenceRef = presenceRootRef.child(user.uid);

    // ——— Presence onDisconnect SAFE ———
let _odHandle; // handle renvoyé par onDisconnect

function presenceArm(){
  try {
    _odHandle = myPresenceRef.onDisconnect();
    _odHandle.remove().catch(()=>{});
  } catch(e){ console.log('[onDisconnect setup]', e); }
}
async function presenceCancel(){
  try { await _odHandle?.cancel?.(); } catch(e){ console.log('[onDisconnect.cancel]', e); }
  finally { _odHandle = undefined; }
}

// Garde d’attachement: n’attache qu’une seule fois (safe global)
if (!('_infoConnAttached' in window)) window._infoConnAttached = false;

if (!window._infoConnAttached) {
  window._infoConnAttached = true;

  infoConnectedRef.on('value', snap => {
    if (snap.val() === true) {
      myPresenceRef.onDisconnect().remove().catch(()=>{});
      myPresenceRef.set({ online: true, ts: firebase.database.ServerValue.TIMESTAMP }).catch(()=>{});
    }
  });
}


// Garde d’attachement: n’attache qu’une seule fois (safe global)
if (!('_presenceAttached' in window)) window._presenceAttached = false;

let online = 0;

if (!window._presenceAttached) {
  window._presenceAttached = true;

  presenceRootRef.once('value').then(s => {
    online = s.numChildren();
    onlineEl.textContent = String(online);
    onlineEl.classList.remove('dim');
  });

  presenceRootRef.on('child_added', ()=>{
    online++;
    onlineEl.textContent = String(online);
  });

  presenceRootRef.on('child_removed', ()=>{
    online = Math.max(0, online-1);
    onlineEl.textContent = String(online);
  });
}


watchValue('stats/clicksTotal', (s)=>{
  _isApplyingRemote = true;
  try {
    clickEl.textContent = String(s.val() || 0);
    clickEl.classList.remove('dim');
  } finally {
    _isApplyingRemote = false;
  }
});

 // Garde d’attachement: n’attache qu’une seule fois
if (!('_pixelsAttached' in window)) window._pixelsAttached = false;

const pixelsRef = db.ref('pixels');

if (!('_pixelsAttached' in window)) window._pixelsAttached = false;
if (!window._pixelsAttached) {
  window._pixelsAttached = true;

  pixelsRef.once('value').then(snap => {
    const val = snap.val() || {};

    // Cache RGB pour convertir les hex plus vite
    const rgbCache = new Map();
    function hexToRgb(hex){
      if (rgbCache.has(hex)) return rgbCache.get(hex);
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      const out = m ? [parseInt(m[1],16), parseInt(m[2],16), parseInt(m[3],16)] : [255,255,255];
      rgbCache.set(hex, out);
      return out;
    }

    // Construire un ImageData logique W×H (une “cellule” = 1 pixel logique)
    const img = ctx.createImageData(W, H);
    const data = img.data;

    // [NOUVEAU] Collecte des UID auteurs uniques
    const uidsToFetch = new Set();

    for (let y = 0; y < H; y++){
      for (let x = 0; x < W; x++){
        const key = `${x}_${y}`;
        const v = val[key] || {};
        const idx = Number.isFinite(+v.color) ? +v.color : 1;

        // Mises à jour de tes grilles mémoires existantes
        grid[y][x] = idx;
        authorGrid[y][x] = v.author || null;
        tsGrid[y][x] = typeof v.ts === 'number' ? v.ts : null;
        if (v.author) uidsToFetch.add(v.author); // [REMPLACÉ] plus de ensureName ici

        // Peinture dans le buffer RGBA
        const [r,g,b] = hexToRgb(colors[idx] || '#FFFFFF');
        const p = (y*W + x) * 4;
        data[p] = r; data[p+1] = g; data[p+2] = b; data[p+3] = 255;
      }
    }

    // Peindre l'ImageData sur un canvas tampon W×H
    const tmp = document.createElement('canvas');
    tmp.width = W; tmp.height = H;
    const tctx = tmp.getContext('2d');
    tctx.putImageData(img, 0, 0);

    // Puis l’upscaler proprement vers ton canvas final (PIX scaling, sans lissage)
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(tmp, 0, 0, canvas.width, canvas.height);
    ctx.restore();

    // Grille si cochée
    if (showGridChk.checked) drawGridOverlay();

    // [NOUVEAU] Déclencher une seule lecture par UID
    for (const uid of uidsToFetch) {
      ensureName(uid);
    }

    // === Listeners temps réel après le rendu initial ===
    pixelsRef.on('child_changed', onPixelUpdate);
    pixelsRef.on('child_added',  onPixelUpdate);
    pixelsRef.on('child_removed', onPixelRemoved);
  });
}



    let overlayQueued = false;
    function queueOverlay(){
      if (!showGridChk.checked) return;
      if (overlayQueued) return;
      overlayQueued = true;
      requestAnimationFrame(()=>{ drawGridOverlay(); overlayQueued = false; });
    }
// --- Batch paint pour les updates temps réel (1 draw par frame) ---
const paintQueue = new Map(); // key "x_y" -> {x,y}
let paintRaf = false;

function schedulePixelPaint(){
  if (paintRaf) return;
  paintRaf = true;
  requestAnimationFrame(()=>{
    paintRaf = false;

    // Dessine toutes les cellules uniques en file
    for (const {x, y} of paintQueue.values()){
      drawCell(x, y);
    }
    paintQueue.clear();

    // Grille (une seule fois après le batch)
    if (showGridChk.checked) drawGridOverlay();
  });
}

function enqueueCell(x, y){
  // Set écrase les doublons "x_y" si plusieurs updates arrivent pour la même case
  paintQueue.set(`${x}_${y}`, { x, y });
  schedulePixelPaint();
}
// ---- Handler commun des updates temps réel (ajout/changement d’un pixel)
function onPixelUpdate(snap){
  const [x,y] = snap.key.split('_').map(Number);
  const v = snap.val() || {};
  const col = Number.isFinite(+v.color) ? +v.color : 1;
  if (x>=0 && x<W && y>=0 && y<H) {
    grid[y][x] = col;
    authorGrid[y][x] = v.author || null;
    tsGrid[y][x] = (typeof v.ts === 'number') ? v.ts : null;
    if (v.author) ensureName(v.author);
    enqueueCell(x, y);           // ← on dessine via le batch/frame
  }
}
    
function onPixelRemoved(snap){
  const [x,y] = snap.key.split('_').map(Number);
  if (x>=0 && x<W && y>=0 && y<H){
    // effacement = retour au "fond" → on force l’index 1 (blanc)
    grid[y][x] = 1;
    authorGrid[y][x] = null;
    tsGrid[y][x] = null;
    enqueueCell(x, y);
  }
}

canvas.addEventListener('click', async (e)=>{
  if (!myName) { openPseudoModal(); return; }
  const rect = canvas.getBoundingClientRect();
  const localX = (e.clientX - rect.left) / zoom;
  const localY = (e.clientY - rect.top)  / zoom;
  const x = Math.floor(localX / PIX), y = Math.floor(localY / PIX);
  if (x<0||x>=W||y<0||y>=H) return;
  if (selected < 0 || selected >= colors.length) return;
  const key = `${x}_${y}`;
 try {
  const pixRef = db.ref(`pixels/${key}`);

  if (selectedIsEraser){
    // ——— ERASE : suppression du nœud → RTDB envoie un child_removed
    await safeSet(pixRef, null);

    // Historique optionnel (trace effacement)
    const histRef = db.ref(`history/${key}`).push();
    await safeSet(histRef, {
      color: null, erase: true,
      author: CURRENT_UID || 'anon',
      ts: firebase.database.ServerValue.TIMESTAMP
    });
  } else {
    const payload = {
      color: selected,
      author: CURRENT_UID || 'anon',
      ts: firebase.database.ServerValue.TIMESTAMP
    };
    await safeSet(pixRef, payload);

    const histRef = db.ref(`history/${key}`).push();
    await safeSet(histRef, payload);
  }

  _clicksBuffer++; scheduleClicksFlush();
} catch (err) {
  console.error('write pixel / click count error', err);
}

});

    canvas.addEventListener('wheel', e => {
      if (e.shiftKey) {
       e.preventDefault();

// Position actuelle dans l'ordre visuel
const curIdx = selectedIsEraser ? 1 : selected;
let pos = PALETTE_ORDER.indexOf(curIdx);
if (pos < 0) pos = 0;

// +1 / -1 dans l'ordre visuel
pos = (e.deltaY > 0)
  ? (pos + 1) % PALETTE_ORDER.length
  : (pos - 1 + PALETTE_ORDER.length) % PALETTE_ORDER.length;

const nextIdx = PALETTE_ORDER[pos];
selected = nextIdx;
selectedIsEraser = (nextIdx === 1);

// Mise à jour visuelle (activeSw)
[...paletteGrid.children].forEach(el => el.classList.remove('activeSw'));
paletteGrid.children[pos]?.classList.add('activeSw');

updateCursor();
      }
    }, { passive: false });
    
// --- Ctrl + molette : zoom autour du pointeur (façon Google Maps) ---
// --- Ctrl/Cmd + molette : zoom rAF-coalescé autour du pointeur ---
let _wheelZoomQueued = false;
let _wheelTargetZoom = null;
let _wheelLastX = 0, _wheelLastY = 0;

viewport.addEventListener('wheel', (e) => {
  if (!(e.ctrlKey || e.metaKey)) return;
  e.preventDefault();

  const factor = (e.deltaY > 0) ? (1 / ZOOM_STEP) : ZOOM_STEP;

  // On accumule les facteurs dans une cible, et on applique 1x par frame
  const base = (_wheelTargetZoom === null) ? zoom : _wheelTargetZoom;
  _wheelTargetZoom = clampZoom(base * factor);
  _wheelLastX = e.clientX; _wheelLastY = e.clientY;

  if (_wheelZoomQueued) return;
  _wheelZoomQueued = true;
  requestAnimationFrame(() => {
    _wheelZoomQueued = false;
    if (_wheelTargetZoom !== null) {
      setZoomAroundPoint(_wheelTargetZoom, _wheelLastX, _wheelLastY);
      _wheelTargetZoom = null;
    }
  });
}, { passive: false });


setInterval(()=>{ if (document.visibilityState === 'visible') tryArchive(); }, 10*1000);
  });

  buildPalette(); updateCursor();
    const _origBuildPalette = buildPalette;
buildPalette = function(){
  _origBuildPalette.apply(this, arguments);
  const newPal = document.getElementById('paletteBar');
  roObserveSafe(newPal);
};
  updatePseudoBtn();

if (window.visualViewport){
  // resize coalescé
  let vvResizeRAF = false;
  visualViewport.addEventListener('resize', ()=>{
    if (vvResizeRAF) return;
    vvResizeRAF = true;
    requestAnimationFrame(()=>{ vvResizeRAF = false; scheduleRelayout(); });
  }, { passive: true });

  // scroll coalescé
  let vvScrollRAF = false;
  visualViewport.addEventListener('scroll', ()=>{
    if (vvScrollRAF) return;
    vvScrollRAF = true;
    requestAnimationFrame(()=>{ vvScrollRAF = false; scheduleRelayout(); });
  }, { passive: true });
}


  // --- Handlers +/− palette
  if (palSizeMinus) palSizeMinus.addEventListener('click', ()=>{
    palScaleIdx = clampIndex(palScaleIdx - 1);
    localStorage.setItem('pw-pal-scale-idx', String(palScaleIdx));
    applyPalScale();
  });
  if (palSizePlus) palSizePlus.addEventListener('click', ()=>{
    palScaleIdx = clampIndex(palScaleIdx + 1);
    localStorage.setItem('pw-pal-scale-idx', String(palScaleIdx));
    applyPalScale();
  });

  // --- Handlers +/− UI haut
  if (uiSizeMinus) uiSizeMinus.addEventListener('click', ()=>{
    uiScaleIdx = clampIndex(uiScaleIdx - 1);
    localStorage.setItem('pw-ui-scale-idx', String(uiScaleIdx));
    applyUiScale();
  });
  if (uiSizePlus) uiSizePlus.addEventListener('click', ()=>{
    uiScaleIdx = clampIndex(uiScaleIdx + 1);
    localStorage.setItem('pw-ui-scale-idx', String(uiScaleIdx));
    applyUiScale();
  });
  // --- Export PNG (x4), fond blanc pour cases vides
  const menuDownloadPNG = document.getElementById('menuDownloadPNG');

  function exportBoardPNG(scale = 4){
    // 1) Peindre un canvas logique W×H à partir de la grille en forçant le blanc (#FFFFFF) pour "vide"
    const base = document.createElement('canvas');
    base.width = W; base.height = H;
    const bctx = base.getContext('2d', { willReadFrequently: false });
    const img = bctx.createImageData(W, H);
    const data = img.data;

    // Couleur par index → RGB
    const rgbCache = new Map();
    function hexToRgb(hex){
      if (rgbCache.has(hex)) return rgbCache.get(hex);
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      const out = m ? [parseInt(m[1],16), parseInt(m[2],16), parseInt(m[3],16)] : [255,255,255];
      rgbCache.set(hex, out);
      return out;
    }

    for (let y=0; y<H; y++){
      for (let x=0; x<W; x++){
        const idx = Number.isFinite(grid[y][x]) ? grid[y][x] : 1; // 1 = #FFFFFF
        const hex = colors[idx] || '#FFFFFF';
        const [r,g,b] = hexToRgb(hex);
        const p = (y*W + x) * 4;
        data[p]   = r;
        data[p+1] = g;
        data[p+2] = b;
        data[p+3] = 255;
      }
    }
    bctx.putImageData(img, 0, 0);

    // 2) Upscale propre x4 (ou autre), sans lissage
    const out = document.createElement('canvas');
    out.width = W * scale; out.height = H * scale;
    const octx = out.getContext('2d');
    octx.imageSmoothingEnabled = false;
    octx.drawImage(base, 0, 0, out.width, out.height);

    // 3) Téléchargement
    out.toBlob((blob)=>{
      const a = document.createElement('a');
      const name = formatParisFilename('export','png'); // déjà fournie dans ton code
      if (!blob){
        a.href = out.toDataURL('image/png');
        a.download = name;
        document.body.appendChild(a); a.click(); a.remove();
        return;
      }
      const url = URL.createObjectURL(blob);
      a.href = url; a.download = name;
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=> URL.revokeObjectURL(url), 0);
    }, 'image/png');
  }

  if (menuDownloadPNG){
    menuDownloadPNG.addEventListener('click', ()=>{
      exportBoardPNG(4); // x4 comme l’Admin
    });
  }


window.addEventListener('load', ()=>{ applyZoom(); scheduleRelayout(); });
window.addEventListener('resize', scheduleRelayout);
window.addEventListener('orientationchange', ()=>{ setTimeout(scheduleRelayout, 200); });

// ——— ResizeObserver SAFE + lifecycle ———
let _roInstance;
let _roQueued = false;

function roEnsure(){
  if (!_roInstance){
    _roInstance = new ResizeObserver(()=>{
      if (isLayingOut) return;
      if (_roQueued) return;
      _roQueued = true;
      requestAnimationFrame(()=>{ _roQueued = false; scheduleRelayout(); });
    });
  }
  return _roInstance;
}
function roObserveSafe(el){
  try { if (el) roEnsure().observe(el); } catch(e){ console.log('[RO observe error]', e); }
}
function roDisconnectSafe(){
  try { _roInstance?.disconnect?.(); } catch(e){ console.log('[RO disconnect error]', e); }
  _roInstance = undefined;
}

// (re)brancher au chargement
roObserveSafe(paletteBar);

// Couper quand l’onglet part (mobile, bfcache), rebrancher au retour
window.addEventListener('pagehide', ()=>{ roDisconnectSafe(); });
window.addEventListener('pageshow', ()=>{ roObserveSafe(document.getElementById('paletteBar')); });

// ⚠️ si tu remplaces le DOM de la palette ailleurs, pense à rappeler roObserveSafe(nouveauNoeud)

/* ro.observe(uiBar); */


document.getElementById('countdown').innerHTML = '<span style="color:#b00020;font-weight:700">Ce soir&nbsp;Minuit</span>';
    
  (function setupOnlineByHourHeartbeat(){
    const PING_EVERY_MS = 5 * 60 * 1000;
    const KEY_PREFIX = 'pw-traffic-last-';

    function dateKey(d){
      const y=d.getFullYear();
      const m=String(d.getMonth()+1).padStart(2,'0');
      const dd=String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${dd}`;
    }
    function hourOf(d){ return d.getHours(); }

    function ping(){
      const now = new Date();
      const dayKey = dateKey(now);
      const hour = hourOf(now);
      const dedupKey = `${KEY_PREFIX}${dayKey}-${hour}`;
      const last = Number(sessionStorage.getItem(dedupKey) || 0);
      if (Date.now() - last < (4 * 60 * 1000)) return;
      sessionStorage.setItem(dedupKey, String(Date.now()));
      db.ref(`stats/onlineByHour/${dayKey}/${hour}`).transaction(cur => (cur || 0) + 1).catch(()=>{});
    }

    setTimeout(ping, 5000);
    let timer = null;
    function start(){ if (timer) return; timer = setInterval(()=>{ if (document.visibilityState === 'visible') ping(); }, PING_EVERY_MS); }
    function stop(){ if (timer){ clearInterval(timer); timer=null; } }

    document.addEventListener('visibilitychange', ()=>{ if (document.visibilityState === 'visible') { ping(); start(); } else { stop(); } });
    window.addEventListener('pagehide', stop);
    window.addEventListener('beforeunload', stop);
// Annule onDisconnect quand l’onglet part ; réarmé automatiquement à la reconnexion
    window.addEventListener('pagehide', ()=>{ presenceCancel(); });

    start();
  })();
// === Connexions par minute (visitsByMinute) ===
// Incrémente 1 fois par minute quand l’onglet est visible.
// Chemin : stats/visitsByMinute/YYYY-MM-DD/HH:mm
(function setupVisitsByMinute(){
  const dbRoot = firebase.database().ref();
  const PING_EVERY_MS = 60 * 1000; // 1 minute

  function dateKey(d){
    const y=d.getFullYear();
    const m=String(d.getMonth()+1).padStart(2,'0');
    const dd=String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${dd}`;
  }
  function minuteKey(d){
    const hh=String(d.getHours()).padStart(2,'0');
    const mm=String(d.getMinutes()).padStart(2,'0');
    return `${hh}:${mm}`;
  }

  let timer = null;
  let lastMinuteStamp = '';

  function pingOnceForCurrentMinute(){
    if (document.visibilityState !== 'visible') return;
    const now = new Date();
    const day = dateKey(now);
    const min = minuteKey(now);
    const stamp = `${day} ${min}`;
    if (stamp === lastMinuteStamp) return; // dédup par minute
    lastMinuteStamp = stamp;
    dbRoot.child(`stats/visitsByMinute/${day}/${min}`)
      .transaction(cur => (cur || 0) + 1)
      .catch(()=>{ /* ignore */ });
  }

  function start(){ if (timer) return; pingOnceForCurrentMinute(); timer = setInterval(pingOnceForCurrentMinute, PING_EVERY_MS); }
  function stop(){ if (!timer) return; clearInterval(timer); timer = null; }

  document.addEventListener('visibilitychange', ()=>{ if (document.visibilityState === 'visible') start(); else stop(); });
  start();
})();
  </script>
  <!-- Fenêtre Règles -->
<div id="rulesOverlay" class="rules-overlay" aria-modal="true" role="dialog" aria-labelledby="rulesTitle" aria-hidden="true">
  <div class="rules-modal">
    <h2 id="rulesTitle">Règles</h2>
    <p>
      Toute représentation offensante, violente ou à caractère sexuel sera suivie d’un bannissement permanent du site.
    </p>
    <p>
      Merci de respecter les règles du vivre-ensemble pour faire de cet endroit un espace de création partagé agréable pour tous.
    </p>
    <div class="rules-actions">
      <span id="rulesCount" class="rules-count">OK disponible dans 10&nbsp;s</span>
      <button id="rulesOkBtn" class="rules-ok" disabled>OK</button>
    </div>
  </div>
</div>
<script>
(function(){
  const KEY_ACCEPT = 'rulesAcceptedV1';
  const overlay = document.getElementById('rulesOverlay');
  const okBtn   = document.getElementById('rulesOkBtn');
  const countEl = document.getElementById('rulesCount');

  let countdown = 10, timerId = null;

  function startCountdown(){
    countdown = 10;
    updateCount();
    okBtn.disabled = true;
    okBtn.classList.remove('enabled');
    clearInterval(timerId);
    timerId = setInterval(()=>{
      countdown--;
      updateCount();
      if (countdown <= 0){
        clearInterval(timerId);
        countEl.textContent = '';
        okBtn.disabled = false;
        okBtn.classList.add('enabled');
        okBtn.focus();
      }
    }, 1000);
  }

  function updateCount(){
    countEl.textContent = `OK disponible dans ${countdown}\u00A0s`;
  }

  function showRules(){
    if (sessionStorage.getItem(KEY_ACCEPT)) return; // une seule fois par session
    overlay.style.display = 'flex';
    overlay.setAttribute('aria-hidden', 'false');
    startCountdown();
    document.addEventListener('keydown', blockEsc, { capture:true });
  }

  function blockEsc(e){ if (e.key === 'Escape'){ e.preventDefault(); } }

  function acceptRules(){
    if (okBtn.disabled) return;
    sessionStorage.setItem(KEY_ACCEPT, '1');
    overlay.style.display = 'none';
    overlay.setAttribute('aria-hidden', 'true');
    document.removeEventListener('keydown', blockEsc, { capture:true });
  }

  okBtn.addEventListener('click', acceptRules);

  // Détection pseudo choisi
  function hasPseudoChosen(){
    const nick = localStorage.getItem('nickname');
    return !!(nick && nick.trim().length);
  }

  if (hasPseudoChosen()) showRules();
  document.addEventListener('pseudo:chosen', ()=>{ showRules(); }, { once:true });

  window.__showRulesAfterPseudo = showRules;
})();
</script>


</body>
</html>


